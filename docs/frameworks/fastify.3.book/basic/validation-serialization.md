---
description: В этой главе вы узнаете, как реализовать безопасные конечные точки с проверкой ввода и сделать их быстрее с помощью процесса сериализации
---

# Изучение валидации и сериализации

Fastify безопасен и быстр, но это не защищает его от злоупотреблений. В этой главе вы узнаете, как реализовать безопасные конечные точки с проверкой ввода и сделать их быстрее с помощью процесса сериализации.

Этот фреймворк предоставляет все необходимые инструменты для использования этих двух критически важных шагов, которые поддержат вас при раскрытии простых интерфейсов API и позволят вашим клиентам использовать их.

Вы узнаете, как использовать и настраивать компоненты Fastify, чтобы контролировать и адаптировать стандартную настройку к логике вашего приложения.

Именно этот путь обучения мы рассмотрим в этой главе:

-   Понимание валидации и сериализации
-   Понимание процесса валидации
-   Настройка компилятора валидатора
-   Управление компилятором валидатора
-   Понимание процесса сериализации

## Технические требования {#technical-requirements}

Как уже упоминалось в предыдущих главах, вам понадобится следующее:

-   Рабочая установка Node.js 18
-   Текстовый редактор для работы с кодом примера
-   HTTP-клиент для тестирования кода, например CURL или Postman.

Все фрагменты в этой главе находятся на [GitHub](https://github.com/PacktPublishing/Accelerating-Server-Side-Development-with-Fastify/tree/main/Chapter%205).

## Понимание валидации и сериализации {#understanding-validation-and-serialization}

Fastify был создан с акцентом на опыт разработчика и на сокращение усилий разработчика, необходимых для создания нового проекта. По этой причине в Fastify встроены функции, позволяющие снизить следующие нагрузки:

-   Проверка правильности ввода данных пользователем
-   Фильтрация вывода сервера.

Цель - найти решения и предотвратить наиболее распространенные атаки безопасности, такие как внедрение кода или раскрытие конфиденциальных данных. Ответ заключается в объявлении ожидаемого формата входных и выходных данных для каждого маршрута. Поэтому процессы валидации и сериализации были введены во фреймворк по проекту:

![Рисунок 5.1 - Этапы валидации и сериализации](validation-serialization-1.png)

<center>Рисунок 5.1 - Этапы валидации и сериализации</center>

Эта предыдущая диаграмма показывает макроархитектуру этапов жизненного цикла запроса, о которой вы подробно читали в [_главе 4_](./hooks.md).

Фаза **Валидация** происходит, когда **HTTP-запрос** поступает на сервер. Он позволяет одобрить или запретить доступ к шагу **Бизнес-логика**.

Этап **Сериализация** преобразует высокоуровневые данные, созданные бизнес-логикой, такие как объекты JSON или ошибки, в низкоуровневые данные (`strings` или `buffers`) для ответа на запрос клиента.

Следующий вопрос: как определить информацию, проходящую через валидацию, и данные ответа? К счастью, решением является спецификация **JSON Schema**, которая принята как Fastify, так и веб-сообществом.

Но что такое JSON Schema? Мы собираемся разобраться в этой важной концепции приложения, которая фокусируется на безопасности и скорости. Следующие разделы скорее теоретические, чем практические: нам нужно знать, как работает система, прежде чем увидеть ее в действии, иначе мы можем упустить важные концепции.

### Спецификация JSON Schema {#the-json-schema-specification}

Стандарт JSON Schema описывает структуру документов JSON. Поэтому, используя интерпретатор JSON Schema, можно проверить, соответствует ли объект JSON определенной структуре, и действовать соответствующим образом.

Написание схемы дает вам возможность применить некоторую автоматизацию к вашему Node.js-приложению:

-   Проверка JSON-объектов
-   Генерация документации
-   Фильтрация полей JSON-объектов

Стандарт все еще находится в стадии черновика и достиг версии 2020-12. По умолчанию Fastify v4 принимает более старую версию спецификации, **Draft-07**, которая широко поддерживается и используется. По этой причине все последующие примеры JSON Schema будут следовать этому стандарту. Давайте посмотрим на практике, как выглядит JSON Schema, попробовав проверить следующий JSON-объект через схему:

```json
{
    "id": 1,
    "name": "Foo",
    "hobbies": ["Soccer", "Scuba"]
}
```

Соответствующая JSON-схема может иметь следующую структуру:

```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "http://foo/user",
    "type": "object",
    "properties": {
        "identifier": {
            "type": "integer"
        },
        "name": {
            "type": "string",
            "maxLength": 50
        },
        "hobbies": {
            "type": "array",
            "items": {
                "type": "number"
            }
        }
    },
    "required": ["id", "name"]
}
```

Как видите, схема представляет собой JSON, который можно читать даже без знания стандартного формата. Давайте попробуем разобраться в ней вместе.

В качестве входных данных мы ожидаем объект `type` с некоторыми свойствами, которые мы назвали и настроили следующим образом:

-   Обязательное поле `identifier` должно быть целым числом
-   Обязательная строка `имя`, которая не может быть длиннее 50 символов
-   Необязательный массив строк `hobbies`.

В этом случае вывод программного интерпретатора, проверяющего, соответствует ли входной JSON схеме, будет успешным. Та же проверка будет неудачной, если входной объект не содержит одного из обязательных полей или если один из типов не соответствует полю `type` схемы.

До сих пор мы говорили о проверке JSON-объекта, но не упоминали о сериализации. Эти два аспекта различны, и их разделяет только спецификация JSON Schema. Спецификация написана с учетом процесса валидации. Сериализация - это приятный «побочный эффект», введенный для повышения безопасности и производительности; мы увидим, как это сделать в этом разделе.

Пример схемы, который мы только что рассмотрели, - это демонстрация базового синтаксиса схемы, который станет более интуитивным. JSON Schema поддерживает большой набор ключевых слов для реализации строгой проверки, таких как значения по умолчанию, рекурсивные объекты, типы ввода даты и времени, формат электронной почты и так далее.

Полный обзор спецификации JSON Schema мог бы занять целую книгу. Поэтому вы можете углубить свои знания по этому аспекту, заглянув на [официальный сайт](https://json-schema.org/). К концу этой главы мы рассмотрим и другие ключевые слова, а новые будут вводиться и описываться постепенно.

Как вы могли заметить, читая предыдущий пример схемы, некоторые ключевые слова имеют префикс в виде символа доллара, `$`. Это специальные метаданные, определенные в проекте стандарта. Одним из наиболее важных и часто используемых является свойство `$id`. Оно однозначно идентифицирует JSON-схему, и Fastify полагается на него для обработки объектов схемы и их повторного использования в приложении.

Ключевое слово `$schema` в примере говорит нам о формате JSON-документа, который является Draft-07. Если вы видите схему JSON на этих страницах, то подразумевается, что она соответствует этой версии из-за настроек Fastify по умолчанию.

Теперь мы имеем представление о том, что такое схема, но как она интегрируется с логикой Fastify? Давайте выясним.

### Составление схемы JSON {#compiling-a-json-schema}

Схемы JSON недостаточно для проверки JSON-документа. Нам нужно преобразовать схему в функцию, которую сможет выполнить наше программное обеспечение. По этой причине необходимо использовать **компилятор**, который выполнит эту работу.

Важно понимать, что компилятор JSON Schema пытается реализовать спецификацию, добавляя ценные функции для облегчения нашей повседневной работы. Это подразумевает знание того, какой компилятор использует ваше приложение, чтобы подправить конфигурацию и получить преимущества от некоторых дополнительных возможностей, таких как новые нестандартные ключевые слова, принудительное приведение типов и дополнительные форматы ввода.

!!!note "Блокировка реализации компилятора"

    Как правило, написание JSON Schema с использованием ключевых слов и возможностей нового компилятора приводит к блокировке. В этом случае вы не сможете изменить компилятор, и у вас могут возникнуть проблемы при интеграции, которая опирается только на стандартные JSON-схемы, например при генерации документов API. Это нормально, если учесть все плюсы и минусы, которые мы представим в этой главе.

Такая же логика была реализована и в процессе сериализации. Идея была довольно проста: если можно построить функцию JavaScript для проверки объекта JSON, то можно скомпилировать новую функцию, которая будет выдавать строку. Строка будет основана только на полях, определенных в источнике схемы JSON!

Следуя этому шагу, вы можете определить только те данные, которые должны входить на ваш сервер и выходить из приложения! Это повышает безопасность приложения. На самом деле, реализация компилятора имеет надежный механизм блокировки инъекций кода, и вы можете настроить его на отбраковку плохих входных данных, таких как слишком длинные `strings`.

Теперь мы прояснили суть JSON Schema и объяснили, как она может помочь улучшить приложение в компоненте компилятора. Давайте разберемся, как Fastify интегрировал эту логику во фреймворк.

### Компиляторы Fastify {#fastifys-compilers}

По умолчанию Fastify имеет два компилятора:

-   **Компилятор валидатора**: Компилирует JSON-схему для проверки входных данных запроса
-   **Компилятор сериализатора**: Компилирует JSON-схему ответа для сериализации данных приложения.

Эти компиляторы, по сути, являются модулями Node.js, которые принимают JSON-схему на вход и выдают нам функцию. Помните об этом, потому что это будет важно позже, в разделе [Создание нового компилятора валидатора](#building-a-new-validator-compiler).

Подробный рабочий процесс Fastify можно представить следующим образом:

![Рисунок 5.2 - Рабочий процесс компиляции JSON-схемы в Fastify](validation-serialization-2.png)

<center>Рисунок 5.2 - Рабочий процесс компиляции JSON-схемы в Fastify</center>

Как вы можете видеть, существует два различных процесса:

-   Инициализация **маршрута**, где схемы компилируются на этапе запуска.
-   Запрос через **Request Lifecycle**, который использует скомпилированные функции, хранящиеся в контексте маршрута.

Теперь вы должны иметь полное представление об общих компонентах Fastify и реализуемой ими логике. Пришло время увидеть все это в действии. Обратите внимание, что для облегчения понимания и во избежание путаницы мы будем обсуждать валидацию и сериализацию отдельно.

## Понимание процесса валидации {#understanding-the-validation-process}

Процесс валидации в Fastify следует одной и той же логике для проверки входящих частей HTTP-запроса. Эта бизнес-логика состоит из двух основных шагов, как мы видели на _рисунке 5.2_:

-   Компиляция схемы, выполняемая **компилятором валидатора**.
-   Выполнение валидации

Мы обсудим эти аспекты по очереди.

### Компилятор валидатора {#the-validator-compiler}

Fastify не реализует интерпретатор JSON Schema самостоятельно. Тем не менее, он интегрировал модуль [Ajv](https://www.npmjs.com/package/ajv) для выполнения процесса валидации. Интеграция Ajv в Fastify реализована для того, чтобы сделать его как можно более быстрым и поддержать инкапсуляцию. Вы всегда сможете изменить настройки по умолчанию и предоставить приложению новый интерпретатор JSON Schema, но как это сделать, мы узнаем позже, в разделе [Управление компилятором валидатора](#managing-the-validator-compiler).

!!!note "Версия Ajv"

    Fastify включил модуль Ajv версии 8. Это важно знать, когда нужно искать новые конфигурации или обращаться за поддержкой к сообществу Ajv. Кроме того, версия Ajv определяет поддерживаемые версии JSON Schema. На момент написания статьи последней версией модуля Ajv является v8, которая поддерживает спецификацию 2020-12.

Компонент компилятора валидатора представляет собой фабричную функцию, которая должна компилировать схемы маршрутов приложения. Каждый маршрут может определять одну схему для каждой части HTTP:

-   `params` для параметров пути
-   `body` для полезной нагрузки
-   `querystring` (или поле псевдонима `query`) для строк запроса URL
-   `headers` для заголовков запроса.

Все эти свойства являются необязательными, поэтому вы можете свободно выбирать, какая часть HTTP должна быть проверена.

Схемы должны быть указаны во время объявления маршрута:

```js
app.post(
    '/echo/:myInteger',
    {
        schema: {
            params: jsonSchemaPathParams,
            body: jsonSchemaBody,
            querystring: jsonSchemaQuery,
            headers: jsonSchemaHeaders,
        },
    },
    function handler(request, reply) {
        reply.send(request.body);
    }
);
```

Готово! Теперь при каждом запуске приложения схемы будут компилироваться компилятором валидатора по умолчанию. Сгенерированные функции будут храниться в контексте маршрута, поэтому каждый HTTP-запрос, который попадает на конечную точку `/echo/:myinteger`, будет выполнять процесс валидации.

Мы можем вызвать конечную точку с неверными данными, чтобы проверить наш код, например, `/echo/not-a-number`. Такой ввод вызовет ошибку валидации, и мы получим ответ `400 Bad Request`:

```json
{
    "statusCode": 400,
    "error": "Bad Request",
    "message": "params.myInteger should be integer"
}
```

Как мы видели, компиляция кажется относительно простой, но вы также должны знать, что эта функция _полностью инкапсулирована_. Этот архитектурный паттерн, который мы уже обсуждали, устроен следующим образом:

-   Один компилятор валидации для разных контекстов плагинов, и они не будут сталкиваться.
-   Вы можете добавлять схемы с одним и тем же `$id` в разные контексты, и они могут иметь разную структуру.

Прежде чем продолжить обсуждение компилятора валидатора и того, как его настраивать и изменять, давайте продолжим этот «счастливый путь», чтобы получить полное представление об одном из ключевых аспектов Fastify.

### Выполнение валидации {#validation-execution}

Fastify применяет валидацию части HTTP-запроса во время жизненного цикла запроса: после выполнения хуков `preValidation` и перед хуками `preHandler`.

Цель этой проверки - проверить формат входных данных и выдать одно из этих действий:

-   **Pass**: Успешно проверяет часть HTTP-запроса.
-   **Deny**: Выбрасывает ошибку, если валидация части HTTP-запроса не прошла.
-   **Append error**: При неудачной проверке части HTTP-запроса и успешном продолжении процесса - настройка опции маршрута `attachValidation`.

Этот процесс не предназначен для проверки корректности данных - для этого следует полагаться на хук `preHandler`.

Как вы видели в предыдущем примере кода, объект `schema` имеет определенную структуру, где каждое свойство сопоставляет HTTP-часть: `params`, `body`, `querystring` и `headers`. Когда вы устанавливаете для JSON-схемы значение `body`, полезная нагрузка HTTP-запроса по умолчанию должна представлять собой JSON-ввод. Вы можете изменить это поведение, и мы рассмотрим, как это сделать в следующем разделе.

В предыдущих главах все наши примеры маршрутов не содержали опцию маршрута `schema`. Таким образом, _мы пропускали фазу проверки_ жизненного цикла запроса.

!!!note "Порядок выполнения проверки"

    Список HTTP-частей, упомянутый в разделе [Компилятор валидатора](#the-validator-compiler), упорядочен по выполнению. Это означает, что если валидация `params` не пройдет, последующие HTTP-части обрабатываться не будут.

Процесс валидации довольно прост. Давайте рассмотрим логику этого процесса более подробно, рассмотрев весь жизненный цикл запроса:

![Рисунок 5.3 - Рабочий процесс выполнения валидации](validation-serialization-3.png)

<center>Рисунок 5.3 - Рабочий процесс выполнения валидации</center>

Давайте разберемся в схеме пошагово:

-   Пунктирная стрелка - это HTTP-запрос, который начал свой жизненный цикл на сервере Fastify и достиг шага хука `preValidation`. Все работает, как ожидалось, и мы готовы начать **выполнение валидации**.
-   Каждая HTTP-часть проверяется, если во время объявления маршрута была предоставлена JSON-схема.
-   Если проверка пройдена, мы переходим к следующему шагу.
-   При неудачной проверке выбрасывается определенный объект `Error`, который будет обработан **обработчиком ошибок**, настроенным в экземпляре сервера, где был зарегистрирован маршрут. Обратите внимание, что ошибка подавляется, если установлена опция маршрута `attachValidation`. Мы рассмотрим пример в разделе [Управление потоком](#flow-control).
-   Если все проверки прошли успешно, жизненный цикл продолжает свой путь к хукам `preHandler`, и дальше все будет происходить так, как обсуждалось в предыдущих главах.
-   Пунктирная рамка **Бизнес-логика** представляет собой выполнение обработчика, которое было опущено, поскольку изображение специально сфокусировано на проверке потока выполнения.

Эти шаги происходят, когда в определении маршрута устанавливается опция схемы, как в предыдущем фрагменте кода в разделе [Компилятор валидатора](#the-validator-compiler).

Теперь у нас есть полный обзор всего процесса валидации, начиная с запуска и заканчивая временем работы сервера. Представленная информация охватывает наиболее распространенные случаи использования приложения и, благодаря настройкам Fastify по умолчанию, готова к использованию.

Отличным приложениям нужны отличные функции. Поэтому сейчас мы сосредоточимся на настройке компилятора валидатора.

## Настройка компилятора валидатора {#customizing-the-validator-compiler}

Fastify предоставляет множество опций для обеспечения гибкого процесса валидации и полного контроля над ним. Мы рассмотрим все возможные настройки по очереди, так что к концу этого раздела вы станете гуру компилятора валидатора! Давайте начнем это путешествие шаг за шагом!

### Управление потоком {#flow-control}

В предыдущем разделе мы упоминали опцию маршрута `attachValidation` - пришло время рассмотреть пример (хотя вы, вероятно, уже знаете, как ее использовать, благодаря предыдущим главам):

```js
app.get('/attach-validation', {
    attachValidation: true,
    schema: {
        headers: jsonSchemaHeaders,
    },
    handler: (request, reply) => {
        reply.send(request.validationError);
    },
});
```

Добавление флага в параметр маршрута предотвратит возникновение ошибки проверки. Вместо этого процесс выполнения валидации будет прерван при первой же ошибке, и процесс будет продолжен, поскольку валидация прошла успешно. В этом случае к аргументу `request` будет присоединен объект `validationError`. Последующие объекты маршрута в жизненном цикле запроса должны справиться с ошибкой и действовать соответствующим образом, иначе ошибка не будет обработана. Как и в предыдущем примере кода, функция-обработчик выполняется всегда.

### Понимание конфигурации Ajv {#understanding-the-ajv-configuration}

Конфигурация Ajv определяет, как строятся функции валидации и как они будут вести себя в тех или иных обстоятельствах. По умолчанию используются следующие настройки, и о них стоит знать:

```json
{
    "coerceTypes": "array",
    "useDefaults": true,
    "removeAdditional": true,
    "uriResolver": require("fast-uri"),
    "allErrors": false,
    "nullable": true
}
```

Давайте разберемся в них, а затем приведем пример, чтобы увидеть все эти опции в действии:

-   Флаг `coerceTypes` пытается привести входные данные к типу, определенному в схеме. Например, если свойством входного тела является строка `foo: "42"`, а само поле определено как `type: integer`, то поле `request.body.foo` будет приведено к типу Number. Значение `array` мы рассмотрим позже в этом разделе.
-   Опция `useDefaults` включает использование ключевого слова `default` JSON Schema, позволяя вам определить начальное значение, если свойство отсутствует или не определено.
-   Параметр `removeAdditional` позволяет удалить из поля HTTP-части все свойства, не указанные в JSON Schema.
-   `uriResolver` - параметр, введенный сообществом Fastify. Он еще больше ускоряет обработку Ajv-модуля.
-   JSON-объект может содержать несколько ошибок валидации, например, два поля с неправильным типом данных. Флаг `allErrors` настраивает функцию валидации на остановку при первой ошибке.
-   Флаг `nullable` позволяет использовать синтаксический сахар ключевого слова `nullable` в схемах JSON.

Эти и другие опции хорошо документированы на сайте [Ajv](https://ajv.js.org/options.html). Вы можете обратиться к ним, чтобы найти новые опции или изменить те, что используются по умолчанию. В разделе [Настройка компилятора валидатора Ajv по умолчанию](#configuring-the-default-ajv-validator-compiler) мы рассмотрим несколько наиболее используемых конфигураций в качестве базовых.

Важно отметить, что эти опции позволяют функции валидации манипулировать исходными данными запроса. Это означает, что исходное тело запроса будет обработано и изменено.

!!!note "Как создается хук предварительной проверки?"

    Хук `preValidation` был впервые введен в ядро Fastify из-за манипуляций с телом, которые выполняли функции валидации. Это было необходимо только в ограниченных случаях, например, для подписанных тел, которые требуют немодифицированного ввода клиента.

Чтобы увидеть все это в действии, вот JSON-схема:

```js
const ajvConfigDemoSchema = {
    type: 'object',
    properties: {
        coerceTypesDemo: { type: 'integer' },
        useDefaultsDemo: {
            type: 'string',
            default: 'hello',
        },
        removeAdditional: {
            type: 'object',
            additionalProperties: false,
            properties: {
                onlyThisField: {
                    type: 'boolean',
                },
            },
        },
        nullableDemo: { type: 'string', nullable: true },
        notNullableDemo: { type: 'string' },
    },
};
```

Эта схема вводит три новых ключевых слова:

-   Свойство `default` позволяет определить значение по умолчанию, когда объект ввода JSON не содержит свойства `useDefaultsDemo` или его значение равно `null`.
-   Параметр `additionalProperties` используется для управления обработкой дополнительных свойств. В примере вы видите `boolean false`, который выводит дополнительные данные из HTTP-части. Объект также может применять более сложные фильтры. Обратитесь к [официальной спецификации](https://json-schema.org/understanding-json-schema/reference/object.html#additional-properties).
-   Флаг `nullable` не определен в стандарте. Это синтаксический сахар, позволяющий избежать стандартного определения типа для `nullable` полей: `{ type: ["string", "null"] }`.

Использование этой схемы в обработчике маршрута даст нам четкое понимание настраиваемых опций:

```js
app.post('/config-in-action', {
    schema: {
        body: ajvConfigDemoSchema,
    },
    handler(request, reply) {
        reply.send(request.body);
    },
});
```

Вызов конечной точки, определенной со следующей полезной нагрузкой, должен установить ответ с измененным телом после выполнения функции проверки:

```sh
curl --location --request POST 'http://localhost:8080/config-in-
action' \
--header 'Content-Type: application/json' \
--data-raw '{
    "coerceTypesDemo": "42",
    "removeAdditional": {
        "remove": "me",
        "onlyThisField": true
    },
    "nullableDemo": null,
    "notNullableDemo": null
}'
```

На выходе мы должны получить такой ответ:

```json
{
    "coerceTypesDemo": 42,
    "removeAdditional": {
        "onlyThisField": true
    },
    "nullableDemo": null,
    "notNullableDemo": "",
    "useDefaultsDemo": "hello"
}
```

Изменения выделены, и каждое название свойства описывает опцию Ajv, которая вызвала изменение.

На данный момент мы имеем полное представление о конфигурации компилятора валидаторов по умолчанию. Это охватывает наиболее распространенные случаи использования и дает вам возможность использовать его из коробки, не мучаясь со сложной конфигурацией и не изучая модуль `Ajv`. К сожалению, для управления реальным приложением крайне важно контролировать все компоненты и конфигурацию Fastify. В следующем разделе вы узнаете, как настроить компилятор валидатора.

## Управление компилятором валидатора {#managing-the-validator-compiler}

Fastify предлагает вам возможность настроить компилятор валидатора двумя различными способами:

-   Настройка стандартного компилятора валидатора Ajv
-   Внедрение совершенно нового компилятора валидаторов, например, нового модуля компилятора JSON Schema.

Эти возможности дают вам полный контроль над процессом валидации и возможность реагировать на любые ситуации, с которыми вы можете столкнуться, например, принять новый модуль компилятора валидатора или управлять тем, как пакет Ajv обрабатывает входные данные.

### Настройка компилятора валидатора Ajv по умолчанию {#configuring-the-default-ajv-validator-compiler}

В разделе [Понимание конфигурации Ajv](#understanding-the-ajv-configuration) мы рассмотрели настройки Ajv по умолчанию и ссылку на его документацию, чтобы изучить их все. Если вы найдете полезные опции, которые хотели бы применить, вы можете установить их во время инстанцирования экземпляра Fastify:

```js
const app = fastify({
    ajv: {
        customOptions: {
            coerceTypes: 'array',
            removeAdditional: 'all',
        },
        plugins: [[require('ajv-keywords'), 'transform']],
    },
});
```

Фабрика Fastify принимает параметр Ajv. Параметр имеет два основных поля:

-   `customOptions` позволяет расширить настройки Ajv. Обратите внимание, что этот JSON будет объединен с настройками по умолчанию.
-   Массив `plugins` принимает внешние плагины Ajv.

В примере используются новые настройки, которые мне больше всего нравятся. Значение `coerceTypes` решает проблему, когда вам нужно получить параметр массива через `querystring`:

```js
app.get('/search', {
    handler: echo,
    schema: {
        query: {
            item: {
                type: 'array',
                maxItems: 10,
            },
        },
    },
});
```

Без `coerceTypes: 'array'`, если ваша конечная точка получает только один параметр, он не будет принудительно приведен к массиву в пределах одного элемента по умолчанию, что приведет к ошибке несоответствия типов. Обратите внимание, что эта опция уже установлена Fastify по умолчанию.

Значение опции `removeAdditional` позволяет избежать переопределения `additional Properties: false` во всех наших объектах схемы. Обратите внимание, что очень важно перечислить все свойства в схемах приложения, иначе вы не сможете прочитать входные данные в своих обработчиках!

!!!note "Объявление короткой схемы JSON Schema"

    В предыдущем примере в схеме запроса отсутствовали некоторые обязательные поля JSON Schema: `type` и `properties`. Fastify обернет входную JSON-схему в родительские JSON-схемы, если не распознает эти два свойства. Так работает синтаксический сахар Fastify, облегчающий настройку маршрута.

После поля опций конфигурации Ajv `customOptions` можно установить свойство `plugins`. Оно добавляет новые возможности и ключевые слова в спецификацию JSON Schema, улучшая работу разработчика.

Опция `plugins` должна представлять собой массив, каждый элемент которого должен быть одним из следующих:

-   Функция плагина Ajv.
-   Двухэлементный массив, где первый элемент - функция плагина Ajv, а второй - опции плагина.

Как это использовать, можно увидеть в следующем фрагменте. Мы регистрируем один и тот же плагин несколько раз для того, чтобы показать синтаксис:

```js
plugins: [
    require('ajv-keywords'), // [1]
    [
        // [2]
        require('ajv-keywords'),
        'transform',
    ],
];
```

Как вы уже убедились, компилятор валидатора Fastify очень настраиваемый и позволяет подобрать оптимальные параметры для вашего приложения. Мы почти охватили все параметры, которые Fastify раскрывает, чтобы настроить компилятор по умолчанию.

До сих пор мы использовали вывод валидации как есть, но если вы задаетесь вопросом, можно ли его настроить, то, конечно, можно! Давайте посмотрим, как это сделать.

### Ошибка валидации {#the-validation-error}

Функция валидатора будет выбрасывать ошибку всякий раз, когда HTTP-часть не соответствует схеме маршрута. Обработчик ошибок контекста маршрута управляет ошибкой. Приведем небольшой пример, показывающий, как пользовательский обработчик ошибок может по-другому управлять ошибкой проверки ввода:

```js
app.get('/custom-error-handler', {
    handler: echo,
    schema: {
        query: { myId: { type: 'integer' } },
    },
});
app.setErrorHandler(function (error, request, reply) {
    if (error.validation) {
        const { validation, validationContext } = error;
        this.log.warn({ validationError: validation });
        const errorMessage = `Validation error on
    ${validationContext}`;
        reply.status(400).send({ fail: errorMessage });
    } else {
        this.log.error(error);
        reply.status(500).send(error);
    }
});
```

Как видите, при неудачной проверке к объекту Error добавляются два параметра:

-   Свойство `validationContext` - это строковое представление HTTP-части, отвечающее за генерацию ошибки
-   Поле `validation` - это необработанный объект ошибки, возвращенный реализацией компилятора валидатора.

Обработчик ошибок Fastify по умолчанию управляет объектом ошибки Ajv и возвращает ясное сообщение об ошибке.

!!!note "Тип данных ошибки проверки"

    Компилятор по умолчанию создает массив ошибок Ajv. Поэтому свойство `validation` генерируется скомпилированной функцией Ajv. Всякий раз, когда мы используем пользовательский компилятор валидатора с новым форматом ошибок, поле `validation` соответствующим образом изменяет свой тип данных.

Настройка обработчика ошибок дает вам возможность сделать так, чтобы ошибки валидации соответствовали формату ошибок, выводимых вашим приложением. Пример мы рассмотрели ранее, в разделе [The validator compiler](#the-validator-compiler).

Если же вам нужно просто настроить сообщение об ошибке, то в Fastify есть опция и для этого! Опция `schemaErrorFormatter` принимает функцию, которая должна сгенерировать объект `Error`, который будет выброшен во время процесса валидации. Эта опция может быть задана следующими способами:

-   Во время инициализации корневого сервера
-   В качестве опции маршрута
-   Или на экземпляре регистрации плагина.

Ниже приведен полный обзор трех возможностей в том же порядке, что и в предыдущем списке:

```js
const app = fastify({
    schemaErrorFormatter: function (errors, httpPart) {
        //[1]
        return new Error('root error formatter');
    },
});
app.get('/custom-route-error-formatter', {
    handler: echo,
    schema: { query: { myId: { type: 'integer' } } },
    schemaErrorFormatter: function (errors, httpPart) {
        //[2]
        return new Error('route error formatter');
    },
});
app.register(function plugin(instance, opts, next) {
    instance.get('/custom-error-formatter', routeConfig);
    instance.setSchemaErrorFormatter(function (
        errors,
        httpPart
    ) {
        // [3]
        return new Error('plugin error formatter');
    });
    next();
});
```

Входная функция `setSchemaErrorFormatter` должна быть синхронной. Она будет получать необработанный объект `errors`, возвращаемый скомпилированной функцией валидации, плюс часть HTTP, которая не является валидной.

До сих пор мы настраивали стандартный компилятор валидатора Fastify, поскольку он генерирует функцию валидации для вывода ошибок. Настроек довольно много, но они позволяют настроить ваш сервер по своему усмотрению, не сталкиваясь со сложностью компиляции. Нам еще предстоит объяснить, как изменить реализацию компилятора валидатора, но сначала мы должны научиться повторно использовать JSON-схемы.

### Повторное использование JSON-схем {#reusing-json-schemas}

На первый взгляд схемы JSON могут показаться огромными и длинными для чтения и понимания. На самом деле, в разделе [The JSON Schema specification](#the-json-schema-specification) мы видели ~20-строчную схему для проверки трехпольного объекта JSON.

Спецификация JSON Schema решает эту проблему, предоставляя возможность повторного использования схемы с помощью ключевого слова `$ref`. Это свойство используется для ссылки на схему и должно представлять собой строковый URI. `$ref` может ссылаться на внешнюю JSON-схему или на локальную схему в самой схеме.

Чтобы сослаться на внешнюю схему, необходимо выполнить следующие два действия:

1.  Установить свойство `$id` внешней схемы и значения `$ref` для ссылки на нее.
2.  Добавьте внешнюю схему в контекст Fastify, вызвав метод `app.addSchema(json Schema)`.

Чтобы лучше понять это, мы рассмотрим пример:

```js
app.addSchema({
    $id: 'http://myapp.com/user.json',
    definitions: {
        user: {
            $id: '#usermodel',
            type: 'object',
            properties: {
                name: { type: 'string', maxLength: 50 },
            },
        },
        address: {
            $id: 'address.json',
            definitions: {
                home: {
                    $id: '#house',
                    type: 'string',
                    maxLength: 150,
                },
                work: {
                    $id: '#job',
                    type: 'string',
                    maxLength: 200,
                },
            },
        },
    },
});
```

Метод `addSchema` принимает в качестве аргумента действительную JSON-схему, которая должна иметь значение `$id`. В противном случае ссылка на схему невозможна. Если значение `$id` отсутствует, будет выдана ошибка. Добавив схему, следуя этому примеру, мы сможем ссылаться на нее в свойстве `schema` конфигурации маршрута.

!!!note "Идентификатор схемы `$id`."

    В предыдущем блоке кода значение `$id` является абсолютным **Uniform Resource (URI)**. Спецификация JSON Schema определяет, что `$id` корневой схемы должен быть в этом формате. Набор URI не обязательно должен быть реальной конечной точкой HTTP, как в примере. Он должен быть уникальным. Следование спецификации поможет вам использовать внешние инструменты для работы со схемами вашего приложения, например, для создания документации. В качестве примера я предпочитаю использовать URI в таком формате: `schema:myapplication:user:create`, что можно обобщить как `schema:<код приложения>:<модель>:<сфера>`.

Чтобы сослаться на [схему](http://myapp.com/user.json), мы должны использовать ключевое слово `$ref`:

```js
app.post('/schema-ref', {
    handler: echo,
    schema: {
        body: {
            type: 'object',
            properties: {
                user: {
                    $ref:
                        'http://myapp.com/user.json#usermodel',
                }, // [1]
                homeAdr: {
                    $ref:
                        'http://myapp.com/address.json#house',
                }, // [2]
                jobAdr: {
                    $ref:
                        'http://myapp.com/address.json#/definitions/work',
                    // [3]
                },
                notes: { $ref: '#/definitions/local' }, // [4]
            },
            definitions: {
                local: { type: 'boolean' },
            },
        },
    },
});
```

Мы использовали четыре различных формата ссылок на URI. Как правило, формат `$ref` имеет следующий синтаксис:

```
<absolute URI>#<local fragment>
```

Here is a brief explanation:

1.  **Reference to an external fragment**: The user’s property points to an external `$id`, defined in the `user.json` URI domain.
2.  **Reference to an external subschema fragment**: `homeAdr` has replaced the absolute URI, from `user.json` to `address.json`. This happens because if `$id` doesn’t start with the `#` char, it is a relative path to the root URI. So, in the external schema, we have defined an `address.json` subschema.
3.  **Relative path to an external subschema**: The local fragment can be a relative path to the JSON Schema to apply. Note that the relative path uses the JSON field name `work` and not the `$id` value.
4.  **Local reference**: You can reference the schema itself. When `$ref` does not have an absolute URI before the `#` char, the local fragment is resolved locally.

This example gives you a complete tool belt and helps you to define your own schema’s references. This setup covers the most common use cases. In fact, the specification is comprehensive and covers many more use cases that could not adapt to our applications. You may refer to the official [documentation example](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-01#section-8.2.4) to deep dive into `$ref` and `$id` linking.

We have learned how to share schemas across the application and use them in our routes’ configuration. But how can we read them? Let’s find out in the next section.

#### Retrieving your schemas {#retrieving-your-schemas}

You must be aware that the schemas added through the `addSchema()` method are stored in a `bucket` component. Every plugin instance has one `bucket` instance to support the encapsulation. Let’s see this code:

```js
app.register(async (instance, opts) => {
    instance.addSchema({
        $id: 'http://myapp.com/user.json',
        type: 'string',
        maxLength: 10,
    });
});
app.register(async (instance, opts) => {
    instance.addSchema({
        $id: 'http://myapp.com/user.json',
        type: 'string',
        maxLength: 50,
    });
});
```

Adding two schemas with the same `$id` is going to throw an error during the startup phase. The usual Fastify logic will apply as always: schemas added in the plugin’s parent scope are inherited in the child one. But, two schemas can have the same `$id` only in different encapsulated contexts.

!!!note "Fastify loves optimizing"

    As mentioned, every plugin context has a `bucket` component that contains all the context’s schemas. This is not totally true. The schema objects could be vast and repetitive. Therefore, Fastify optimizes the bucket logic to reduce the `bucket` instances to the minimum that is needed to isolate them in an encapsulated context. For example, adding all the shared application’s schemas in the root context leads to a single `bucket` instance.

To read the application’s schemas from the `bucket` component, you can use these methods:

```js
const json = instance.getSchema(
    'http://myapp.com/user.json'
);
const jsonIdSchemaPair = instance.getSchemas();
```

`getSchema(id)` needs a string argument within the `$id` to retrieve the corresponding schema. The `getSchemas()` method returns a JSON key-value pair where the key is the schema’s `$id` and the value is the JSON Schema itself.

Now we know about all the aspects of the default validator compiler, how can we configure and extend it? It is time to drop it in favor of a custom one!

### Building a new validator compiler {#building-a-new-validator-compiler}

Fastify’s validator compiler can be replaced totally. You may need to do this in the following situations:

-   You need a unique validator compiler for each HTTP part. For example, you need a specific Ajv configuration for the body part and a different configuration for `querystring`.
-   You prefer to use a different JSON Schema compiler module, such as `@hapi/joi` or `yup`.
-   You want to build your compiler to optimize your application.

It is important to keep in mind that rewriting this Fastify component requires knowing the validation flow, because not being able to find the schemas is one of the most common pitfalls.

Fastify provides you with a couple of ways to substitute the compiler:

-   The root instance’s **Schema Controller Factory**
-   The root or plugin’s validator or serializer compiler component

These two options interact with each other as shown in the following diagram:

![Figure 5.4 – The compiler’s customization process](validation-serialization-4.png)

<center>Figure 5.4 – The compiler’s customization process</center>

During the startup, Fastify decides when it needs a validator compiler or serializer compiler, based on the following questions:

-   Does the root or the plugin instance need a compiler?
-   Does the root or the plugin instance have a compiler already?
-   Are the `bucket` schemas changed, compared to the parent instance?

When all these conditions are met, Fastify asks the schema controller factory to build a new compiler. Note that the following logic applies to both the validator compiler and the serializer compiler. We are going to focus on the validator compiler, but the flow is the same for each of them. We will explore the serializer compiler in the [The serializer compiler](#the-serializer-compiler) section.

The input to produce the compiler is as follows:

-   The compiler option. For the validation compiler, it corresponds to the application’s `ajv` option property.
-   The instance’s `bucket` schemas.

Within these arguments, the factory must produce a Fastify compiler.

The validator compiler is a function that, given the route’s schemas, must return a new function to validate the HTTP request’s parts – we know, it seems a bit tricky, but let’s look at a complete example to understand this idea:

```js
const app = fastify({
    schemaController: {
        // [1]
        compilersFactory: {
            buildValidator: myCompilerFactory, // [2]
        },
    },
});
app.addSchema({
    $id: 'http://myapp.com/string.json',
    type: 'string',
    maxLength: 50,
});
function myCompilerFactory(
    externalSchemas,
    ajvServerOption
) {
    return myValidatorCompiler; // [3]
}
function myValidatorCompiler(routeData) {
    const { schema, method, url, httpPart } = routeData;
    return function validate(jsonPayload) {
        // [4]
        return true;
    };
}
```

The example shows all the schema controller’s entities, which are just simple functions that don’t really do anything. Still, they provide us with an excellent overview of how the single parts can work together, adding some `console.log` statements during your experiments.

!!!note "Disclaimer"

    Be patient and try to follow the code: we are going to explore a function that returns a function that returns another function! It is pretty easy to get lost when first reading it, but hang in there!

There is a new `schemaController` option `[1]`. This parameter lets us configure and take control of the compilers through the `compilersFactory` object. It accepts two parameters, `buildValidator` and `buildSerializer`.

We are going to focus on the former: providing a function `[2]` as input. The `myCompilerFactory` function can access all the instance’s schema via the `externalSchemas` argument and `ajvServerOption`. In this example, there is just one external schema, `'http://myapp.com/string.json'`, and the ajv server options are empty.

!!!note "External schemas"

    The `externalSchemas` argument is provided by Fastify’s schemas bucket. It is populated by calling `instance.getSchemas()` internally. The word “external” refers to those schemas that are referenced by the routes’ schemas.

`myCompilerFactory` is executed whenever Fastify needs a new compiler, based on the checklist we saw at the beginning of this section. For example, the smallest memory footprint case is set by calling this function once: there is only one validator compiler for the whole application.

!!!note "Fastify uses the same APIs exposed to the user"

    It is important to mention that Fastify uses this API to implement the default schema controller. The default `myCompilerFactory` implementation creates the default Ajv instance, and it is isolated in an external module named `@fastify/ajv-compiler`. Thanks to this module, it is possible to run Fastify with a different Ajv version out of the box. Please give it a check!

The `myCompilerFactory` function returns the `myValidatorCompiler` function `[3]`. The latter function target is to “compile” the input schema and transform it into an executable JavaScript function. The `myValidatorCompiler` function is executed during the startup phase, once for every route’s JSON Schema. The `routeData` argument is an object within the route’s coordinates where the following applies:

-   `schema` is the object provided to the route’s schema option (sorry for the redundancy).
-   `method` is the route’s HTTP method string in uppercase.
-   `url` is the raw route’s URL string. For example, the path parameters such as `/hello/:name`.
-   `httpPart` tells us which HTTP request’s part should be validated. It can be one of the well- known `body`, `params`, `querystring`, or `headers` strings.

The `myValidatorCompiler` `[3]` function returns... another function! It is the last one, I swear. The `validate` `[4]` function is what the compilation of the schema must produce. It is stored in the route’s context and executed for every HTTP request routed to that endpoint. We saw the schema of this process in _Figure 5.3_.

The `validate` function is the one that is run when the server is listening. The `schemaController` flow, we have just seen, is executed once during the startup, and it is the heaviest task Fastify must complete before accepting incoming requests. To put it in practice, Fastify’s default `schemaController` component uses the Ajv module to build these `validate` functions – no more, no less.

In the example, we customized `schemaController` with a validation that always returns `true`. But we could implement our logic based on `httpPart`, such as using a primary validation function for `querystring` and `headers` and a more complex one for the `body` part. The most common use case is to apply different ajv settings for each HTTP part. You can find a complete example at <https://github.com/fastify/help/issues/128>.

Congratulations! You have explored the hardest and most complicated Fastify components. It could take a while before gaining full control over these functions, so don’t rush – take your time. Keep in mind that it is fine to not customize the schema controller and use the default one. This section’s takeaway is how the system works under the hood, but it’s still a valuable option to explore because then you will not have nasty surprises during your application development.

Now that you have learned about the Schema Controller Factory component and its configuration and customization, we can move on. Keep calm; it will be easier from now on.

### Customizing the schema validator compiler {#customizing-the-schema-validator-compiler}

In the previous section, we explored the Schema Controller Factory, one of the two ways to substitute Fastify’s schema compiler. Looking at _Figure 5.4_ and the conditions to check whether Fastify must create a compiler, we can tackle the question _Does the root or the plugin instance have a compiler already?_

Customizing the schema validator is quite easy at this point:

```js
app.setValidatorCompiler(myValidatorCompiler); // [1]
app.register(async function plugin(instance, opts) {
    instance.setValidatorCompiler(myValidatorCompiler); // [2]
    app.post('/schema-ref', {
        handler: echo,
        validatorCompiler: myValidatorCompiler, // [3]
        schema: {
            body: mySchema,
        },
    });
});
```

The `myValidatorCompiler` variable is the same as in the previous section: it has the same interface and the same result is returned.

As you know, Fastify lets you customize the schema compiler in two different stages:

-   Customize the validator compiler for the root application instance `[1]` or plugin instance `[2]`
-   Customize the validator compiler for a single route through the route’s options `[3]`

As we have just seen in the example, customizing the validator compiler forces Fastify to skip the Schema Controller Factory call. The function you provide is used instead of building it.

This type of customization is easier to apply compared to the Schema Controller Factory, and it gives you the possibility to change even the tiniest pieces of your application. The typical function of this feature is to support two different compilers in the same Fastify application. This is really useful to migrate applications written using the `joi` module. The following code shows an example:

```js
app.register(async function plugin(instance, opts) {
    function joiCompiler({
        schema,
        method,
        url,
        httpPart,
    }) {
        return function (data) {
            return schema.validate(data);
        };
    }
    instance.setValidatorCompiler(joiCompiler);
    instance.post('/joi', {
        handler: echo,
        schema: {
            body: Joi.object({
                hello: Joi.string().required(),
            }),
        },
    });
});
```

All the routes registered in the `plugin` rely on the `joiCompiler` returned function to validate the HTTP parts. Notice that the `schema` argument is actually a `Joi.object()` instance object. It has been provided during the route registration, and it is not a standard JSON Schema at all. Fastify doesn’t complain about this because you have provided a custom validator compiler, so it is okay if the provided compiler knows how to manage the input schema object.

The routes registered out of the plugin context rely on Fastify’s default validator compiler! We must thank the encapsulation yet again!

Now the validation process and all its pieces have no more secrets for you. You have acquired a deep knowledge of how your routes’ input is validated before executing the handler.

It is time to meet the serializer compiler, but don’t worry, the concepts we explored in this extensive section will be the same in the next one.

## Understanding the serialization process {#understanding-the-serialization-process}

Serialization is the process of transforming complex objects or primitive data into a valid data type that can be transmitted to the client. A **valid data type** is a String, a Stream, or a Buffer.

In the [Understanding validation and serialization](#understanding-validation-and-serialization) section, we introduced the concept of Fastify’s serialization process, which uses JSON schemas to adapt a response payload to a defined format. This is the only task that this process carries out. It doesn’t apply any sort of validation of the output. This is often confusing because the JSON Schema is associated with the validation phase. Therefore, it would be more appropriate to compare it to filter processing rather than to a validation.

The actors in action are quite similar to what we saw in the [Building a new validator compiler](#building-a-new-validator-compiler) section, with some additions. In the following diagram, _Figure 5.5_, we are going to present these additions, extending the **Serialization** box we saw in _Figure 5.3_:

![Figure 5.5 – The serialization workflow](validation-serialization-5.png)

<center>Figure 5.5 – The serialization workflow</center>

_Figure 5.5_ shows the complete workflow Fastifty carries out to serialize the response payload you are sending, calling `reply.send()` or executing a `return` statement in an `async` handler.

!!!note "Too many payloads"

    To improve this section’s clarity, we will name the endpoint’s output object a **response payload**. For reference, it is the one that you give as an argument to the `reply.send()` method. The **serialized payload** is the response payload transformed to a valid data type and ready to be transmitted to the client.

The diagram might look a bit complex, but it condenses these Fastify rules:

-   It is sending or returning an object that is not a String, a Buffer, or a Stream that triggers the serialization process
-   Returning or throwing an error object will trigger the error handler we saw in [Chapter 3](./routes.md)
-   Fastify applies a fallback to avoid starving requests due to a component’s misuse, such as throwing an error in an error handler

Let’s start analyzing _Figure 5.5_ in detail. The first thing that stands out is that the serialization process is skipped when the response payload is a valid data type. This usually happens for web page rendering or for a file download.

When the response payload is not valid, it is processed by five main blocks that manage the payload:

-   The `preSerialization` hooks manipulate the payload before the serialization. We saw this in action in [Chapter 4](./hooks.md).
-   The error handler must manage the error and reply to the HTTP request. As you can see, it is executed only once, but we read about it in [Chapter 3](./routes.md).
-   The **Reply Serializer** is a new simple component. It must convert the object to a valid data type.
-   The **Route’s Serialization Function** is produced by the serializer compiler.
-   The last one, the **Default Reply Serializer**, acts when there is no customization.

Thanks to the flowchart, it should be easier to navigate through the serialization process. For example, it is clear that a custom reply serializer has priority over the serialization function. But let’s look at the code to learn how to use these components to serialize a response payload.

### The reply serializer {#the-reply-serializer}

This component helps you manage a response that is not JSON and needs to be serialized in a different format. It is a synchronous function that must return a valid data type (a String, or a Stream, or a Buffer). If something else is returned or thrown, a fatal error will be sent in response. The reply serializer’s `this` context is the reply object itself – it may be helpful to set additional headers.

The usage is quite straightforward at this point of your path through the Fastify world:

```js
function mySerializer(payload, statusCode) {
    return `<payload>${payload}</payload>`;
}
app.setReplySerializer(mySerializer); // [1]
app.get('/reply-serializer', function handler(
    request,
    reply
) {
    reply
        .type('application/xml')
        .serializer(mySerializer) // [2]
        .send({ hello: 'world' });
});
```

You can assign a custom serializer to the root or plugin server instance `[1]`. As always, in this case, all the routes registered in that context will run it.

The other option is to run the custom serializer only when needed to call the `reply.serializer()` method and passing `serializer` as an argument `[2]`. Remember to set the content-type header in this case, or you may encounter Fastify’s unpredictable results.

That is all you must know about the reply serializer. This component is used to reply with content types that are not JSON, such as XML, compression buffers, YML, and so on.

Having closed this parenthesis, we can start to complete our serialization journey by discussing the serialization function produced by the serializer compiler.

### The serializer compiler {#the-serializer-compiler}

The serializer compiler builds a JavaScript function from a JSON Schema to serialize the response payload. It removes all the fields that are not declared in the schema, and it coerces the output fields’ type. These are the tasks that Fastify’s default serializer compiler does.

The module that compiles the JSON Schemas is [`fast-json-stringify`](https://www.npmjs.com/package/fast-json-stringify).

!!!note "The speed increment"

    The serialization process through a compiled function reduces the time taken to serialize the response’s JSON object. The `fast-json-stringify` and Fastify modules have published a comprehensive [benchmark](https://github.com/fastify/benchmarks/) that compares them to other frameworks too.

But how can we use the JSON Schema to serialize the payload? Let’s see an example:

```js
app.post('/filter', {
    async handler(request, reply) {
        return {
            username: 'Foo',
            password: 'qwerty',
        };
    },
    schema: {
        response: {
            '2xx': {
                type: 'object',
                properties: {
                    username: { type: 'string' },
                },
            },
        },
    },
});
```

The code snippet shows a new option field on the schema route’s options object: the `response` property. It accepts a JSON object where each key must be the following:

-   An HTTP status code such as `200`, `404`, or `500`
-   An HTTP status code pattern looks like: `2xx`, meaning all the status codes from `200` to `299`

In this way, you can customize every response payload with a defined JSON Schema.

As you can see, the `/filter` endpoint returns a `password` field, but thanks to the response schema, it will not be sent to the client! The schema object will use the same schemas within the `$ref` keyword as the validator compiler: they share the `bucket` schemas, as said in the [How to build a new validator compiler](#building-a-new-validator-compiler) section.

!!!note "Knowing the default serializer compiler"

    The `fast-json-stringify` module has its own implementation, and it doesn’t support all the keywords provided by the Ajv validator. This is understandable because they have different functions. One great example you need to learn from is that, while the `maxLength` property of a string field is fundamental to validate the input, it is ignored by the default JSON serializer. Remember, the default JSON Schema serialization doesn’t validate the data; it only filters and coerces the types.

Now we know how to use Fastify’s default serializer compiler, but how is it possible to customize it? Let’s learn about it in the next section.

### Managing the serializer compiler {#managing-the-serializer-compiler}

Just as you can customize the validator compiler, you can do the same with the serializer compiler. To complete the code snippet described in _Figure 5.5_, check out the following code:

```js
const app = fastify({
    serializerOpts: { rounding: 'ceil' },
    schemaController: {
        compilersFactory: {
            buildSerializer: myFactory, // [1]
        },
    },
});
app.addSchema({
    $id: 'http://myapp.com/string.json',
    type: 'string',
});
function myFactory(
    externalSchemas,
    serializerOptsServerOption
) {
    return mySerializerCompiler; // [2]
}
function mySerializerCompiler(routeData) {
    const {
        schema,
        method,
        url,
        httpStatus,
    } = routeData[3]; //
    return function serializer(responsePayload) {
        // [4]
        return `This is the payload ${responsePayload}`;
    };
}
```

The source code should look very familiar to you: the logic flow is the same as we discussed in the [How to build a new validator compiler](#how-to-build-a-new-validator-compiler) section, with minimal changes:

1.  The `compilersFactory` option accepts the new `buildSerializer` property.
2.  The `myFactory` function receives the `serializerOptsServerOption` input equal to the `serializerOpts` object (instead of the `ajv` one).
3.  The `mySerializerCompiler` function receives `httpStatus` as route data `[3]`. The validator receives `httpPart`.
4.  The compiler must return a synchronous function [4] that builds a string object.

The compiled function is then stored in the route’s context, and it will be executed when the serialization process requires it, as we saw in _Figure 5.5_.

Finally, like the validator compiler, you can set the serializer compiler in every context you need it:

```js
app.setSerializerCompiler(mySerializerCompiler); // [1]
app.register(async function plugin(instance, opts) {
    instance.setSerializerCompiler(mySerializerCompiler)[2]; //
    app.post('/respose-schema', {
        handler: echo,
        serializerCompiler: mySerializerCompiler, // [3]
        schema: {
            response: {
                '2xx': mySchema,
                '5xx': myErrorSchema,
            },
        },
    });
});
```

The Fastify way to customize the compiler is consistent with the validator way:

-   Customize the serializer compiler for the root application instance `[1]` or the plugin instance `[2]`
-   Customize the serializer compiler for a single route through the route’s options `[3]`

We have explored the serializer compiler without annoying you by repeating the logic behind the schema controller.

You should be able to customize Fastify’s serializer and change the module that implements schema compilation by adopting the library that best fits your needs. As you have read, Fastify keeps its components consistent, adopting solid patterns that ease your learning curve and improve the framework itself.

## Summary {#summary}

This chapter has followed a long path inside Fastify’s internals to unveil the JSON schema’s power. Now you understand why defining a JSON Schema is a critical phase in your application setup. It can be a hard task, but data validation and a fast response are the two main reasons to do this.

We have looked at the JSON Schema specification’s basics and how to use it in our routes, adopting the default Fastify components. We did not step back to configure these components, and now you have seen the whole process, you can control them to reach your goals.

It has not been easy. The concepts in this chapter are the most misused by developers that use Fastify. You did a great job, and I hope the diagrams have helped you follow the logic behind the validation and the serialization.

This chapter is the last theoretical one: congratulations! In many chapter’s sections, we read concepts that were already discussed in the previous chapters. This is proof that the Fastify architecture is recursive in all its components.

Now, things are getting serious: in the next chapter, we will start building a real application that we’ll use for the rest of the book to create a solid, reusable scaffolding project.

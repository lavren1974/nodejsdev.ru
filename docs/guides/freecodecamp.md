# Полное руководство по Node.js — Изучите Node для начинающих

## Введение в Node.js {#introduction-to-node-js}

Это руководство является руководством по началу работы с Node.js, серверной средой выполнения JavaScript.

### Обзор

Node.js - это **среда выполнения для JavaScript**, которая работает на **сервере**.

Node.js с открытым исходным кодом, кросс-платформенный, и с момента своего появления в 2009 году он приобрел огромную популярность и сейчас играет значительную роль на сцене веб-разработки. Если звезды GitHub являются одним из факторов популярности, то наличие 58000+ звезд означает большую популярность.

Node.js запускает движок V8 JavaScript, ядро Google Chrome, вне браузера. Node.js может использовать работу инженеров, которые сделали (и будут продолжать делать) Chrome JavaScript runtime молниеносно быстрым, и это позволяет Node.js воспользоваться огромными улучшениями производительности и компиляцией Just-In-Time, которую выполняет V8. Благодаря этому код JavaScript, выполняемый в Node.js, может стать очень производительным.

Приложение Node.js выполняется одним процессом, без создания нового потока для каждого запроса. Node предоставляет набор примитивов асинхронного ввода-вывода в своей стандартной библиотеке, которые предотвращают блокировку кода JavaScript, и в целом библиотеки в Node.js написаны с использованием неблокирующих парадигм, что делает блокирующее поведение скорее исключением, чем нормой.

Когда Node.js необходимо выполнить операцию ввода-вывода, например, чтение из сети, доступ к базе данных или файловой системе, вместо блокировки потока Node.js возобновит операции после получения ответа, вместо того чтобы тратить циклы процессора на ожидание.

Это позволяет Node.js обрабатывать тысячи одновременных соединений с одним сервером без необходимости управления параллелизмом потоков, что стало бы основным источником ошибок.

Node.js имеет уникальное преимущество, поскольку миллионы разработчиков фронтенда, которые пишут JavaScript для браузера, теперь могут выполнять код на стороне сервера и код на стороне фронтенда без необходимости изучать совершенно другой язык.

В Node.js можно без проблем использовать новые стандарты ECMAScript, поскольку вам не нужно ждать, пока все ваши пользователи обновят свои браузеры --- вы сами решаете, какую версию ECMAScript использовать, изменяя версию Node.js, и вы также можете включить определенные экспериментальные функции, запустив Node с флагами.

#### Он содержит огромное количество библиотек.

Благодаря своей простой структуре менеджер пакетов node ([npm](https://flaviocopes.com/npm/){rel="noopener"}) помог экосистеме Node.js разрастись. Сейчас в реестре [npm](https://www.npmjs.com/){rel="noopener"} размещено почти 500 000 пакетов с открытым исходным кодом, которые вы можете свободно использовать.

### Пример приложения Node.js {#a-sample-node-js-application}

Самый распространенный пример Hello World из Node.js - это веб-сервер:

```language-js
const http = require('http')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) => {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World\n')
})

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`)
})
```

Чтобы запустить этот фрагмент, сохраните его как файл `server.js` и запустите `node server.js` в терминале.

Этот код сначала включает в себя [модуль] Node.js `http` (https://nodejs.org/api/http.html){rel="noopener"}.

Node.js имеет удивительную [стандартную библиотеку](https://nodejs.org/api/){rel="noopener"}, включая первоклассную поддержку сетевых технологий.

Метод `createServer()` из `http` создает новый HTTP-сервер и возвращает его.

Сервер настроен на прослушивание указанного порта и имени хоста. Когда сервер готов, вызывается функция обратного вызова, в данном случае информирующая нас о том, что сервер запущен.

При получении нового запроса вызывается функция `request` [event](https://nodejs.org/api/http.html#http_event_request){rel="noopener"}, которая предоставляет два объекта: запрос (объект [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage){rel="noopener"}) и ответ (объект [`http.ServerResponse`](https://nodejs.org/api/http.html#http_class_http_serverresponse){rel="noopener"}).

Эти 2 объекта необходимы для обработки HTTP-вызова.

Первый предоставляет детали запроса. В этом простом примере он не используется, но вы можете получить доступ к заголовкам запроса и данным запроса.

Второй используется для возврата данных вызывающей стороне.

В данном случае с:

```language-js
res.statusCode = 200
```

Мы устанавливаем свойство `statusCode` в `200`, чтобы указать на успешный ответ.

Мы устанавливаем заголовок Content-Type:

```language-js
res.setHeader('Content-Type', 'text/plain')
```

...и мы завершаем закрытие ответа, добавляя содержимое в качестве аргумента к `end()`:

```language-js
res.end('Hello World\n')
```

### Node.js фреймворки и инструменты {#node-js-frameworks-and-tools}

Node.js - это низкоуровневая платформа. Чтобы сделать работу разработчиков проще и интереснее, на базе Node.js были созданы тысячи библиотек.

Многие из них со временем стали популярными. Вот неполный список тех, которые я считаю очень важными и достойными изучения:

- [**Express**](https://expressjs.com/){rel="noopener"}\
  Один из самых простых и в то же время мощных способов создания веб-сервера. Его минималистский подход и беспристрастное внимание к основным функциям сервера является ключом к его успеху.
- [**Meteor**](https://flaviocopes.com/meteor/){rel="noopener"}\
  Невероятно мощный фреймворк полного стека, позволяющий использовать изоморфный подход к созданию приложений на JavaScript и разделять код на клиенте и сервере. Когда-то он был готовым инструментом, который предоставлял все, но теперь он интегрируется с такими библиотеками front-end, как [React](https://flaviocopes.com/react/){rel="noopener"}, [Vue](https://flaviocopes.com/vue-introduction/){rel="noopener"} и [Angular](https://angularjs.org/){rel="noopener"}. Meteor можно использовать и для создания мобильных приложений.
- [**Koa**](http://koajs.com/){rel="noopener"}\
  Созданный той же командой, что и Express, Koa стремится быть еще проще и меньше, опираясь на многолетние знания. Новый проект родился из необходимости создавать несовместимые изменения, не нарушая существующего сообщества.
- [**Next.js**](https://flaviocopes.com/nextjs/){rel="noopener"}\
  Это фреймворк для рендеринга приложений на стороне сервера [React](https://reactjs.org/){rel="noopener"}.
- [**Micro**](https://github.com/zeit/micro){rel="noopener"}\
  Это очень легкий сервер для создания асинхронных HTTP микросервисов.
- [**Socket.io**](https://socket.io/){rel="noopener"}\
  Это механизм коммуникации в реальном времени для создания сетевых приложений.

### Краткая история Node.js {#a-brief-history-of-node-js}

#### Взгляд на историю Node.js с 2009 года по сегодняшний день {#a-look-back-on-the-history-of-node-js-from-2009-to-today}

Хотите верьте, хотите нет, но Node.js существует всего 9 лет.

Для сравнения, JavaScript - 23 года, а Интернету, каким мы его знаем (после появления Mosaic), - 25 лет.

9 лет - это такой маленький срок для технологии, но Node.js, кажется, существует уже целую вечность.

Я имел удовольствие работать с Node.js с самых ранних дней, когда ему было всего 2 года, и, несмотря на малое количество доступной информации, уже тогда можно было почувствовать, что это огромная вещь.

В этом разделе я хочу нарисовать общую картину Node.js в ее истории, чтобы представить все в перспективе.

#### Немного истории

JavaScript - это язык программирования, который был создан в компании Netscape как инструмент сценариев для манипулирования веб-страницами в браузере [Netscape Navigator](https://en.wikipedia.org/wiki/Netscape_Navigator){rel="noopener"}.

Частью бизнес-модели Netscape была продажа веб-серверов, которые включали среду под названием "Netscape LiveWire", которая могла создавать динамические страницы с помощью JavaScript на стороне сервера. Так что идея серверного JavaScript не была представлена Node.js, она стара, как и JavaScript --- но в то время она не была успешной.

Одним из ключевых факторов, который привел к появлению Node.js, было время. Несколько лет назад JavaScript начал считаться серьезным языком, благодаря приложениям "Web 2.0", которые показали миру, каким может быть современный опыт работы в Интернете (вспомните Google Maps или GMail).

Планка производительности движков JavaScript значительно поднялась благодаря конкурентной борьбе браузеров, которая продолжается до сих пор. Команды разработчиков каждого крупного браузера ежедневно трудятся над тем, чтобы обеспечить нам лучшую производительность, что является огромной победой для JavaScript как платформы. Chrome V8, движок, который Node.js использует под капотом, является одним из них, и в частности это движок Chrome JavaScript.

Но, конечно, Node.js не стал популярным только благодаря чистой удаче или времени. Он привнес много новаторских идей о том, как программировать на JavaScript на сервере.

#### 2009 {#2009}

- Рождение Node.js
- Создана первая форма [npm](https://flaviocopes.com/npm/){rel="noopener"}

#### 2010 {#2010}

- [Express](https://flaviocopes.com/express/){rel="noopener"} рождается
- [Socket.io](https://socket.io/){rel="noopener"} рождается

#### 2011 {#2011}

- npm достигает версии 1.0
- Крупные компании начинают внедрять Node: [LinkedIn](https://www.linkedin.com){rel="noopener"}, [Uber](https://www.uber.com){rel="noopener"}
- [Hapi](https://hapijs.com/){rel="noopener"} рождается

#### 2012 {#2012}

- Внедрение продолжается очень быстро

#### 2013 {#2013}

- Первая большая блоггерская платформа, использующая Node.js: [Ghost](https://ghost.org/){rel="noopener"}
- [Koa](https://koajs.com/){rel="noopener"} рождается

#### 2014 {#2014}

- Большая драма: [IO.js](https://iojs.org/){rel="noopener"} - крупный форк Node.js, с целью внедрения поддержки ES6 и более быстрого движения вперед

#### 2015 {#2015}

- Рождение [Node.js Foundation](https://foundation.nodejs.org/){rel="noopener"}.
- IO.js вливается обратно в Node.js
- npm вводит приватные модули
- [Node 4](https://nodejs.org/en/blog/release/v4.0.0/){rel="noopener"} (ранее не выпускались версии 1, 2, 3)

#### 2016 {#2016}

- [leftpad incident](https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm){rel="noopener"}
- [Yarn](https://flaviocopes.com/yarn/){rel="noopener"} рождается: Узел 6

#### 2017 {#2017}

- npm уделяет больше внимания безопасности: Node 8
- [HTTP/2](https://nodejs.org/api/http2.html){rel="noopener"}
- [V8](https://flaviocopes.com/v8/){rel="noopener"} вводит Node в свой набор тестирования, официально делая Node целью для движка JavaScript, в дополнение к Chrome
- 3 миллиарда загрузок npm каждую неделю

#### 2018 {#2018}

- Node 10
- [ES-модули](https://flaviocopes.com/es-modules/){rel="noopener"} экспериментальная поддержка .mjs

### Как установить Node.js {#how-to-install-node-js}

#### Как можно установить Node.js на вашу систему: пакетный менеджер, установщик с официального сайта или nvm {#how-you-can-install-node-js-on-your-system-a-package-manager-the-official-website-installer-or-nvm}

Node.js может быть установлен различными способами. В этой заметке освещены наиболее распространенные и удобные из них.

Официальные пакеты для всех основных платформ доступны [здесь](https://nodejs.org/en/download/){rel="noopener"}.

Один из очень удобных способов установки Node.js - через менеджер пакетов. В данном случае у каждой операционной системы он свой.

На macOS стандартом де-факто является [Homebrew](https://brew.sh/){rel="noopener"}, который --- после установки --- позволяет установить Node.js очень легко, выполнив эту команду в CLI:

    brew install node

Другие менеджеры пакетов для Linux и Windows перечислены [здесь](https://nodejs.org/en/download/package-manager/){rel="noopener"}.

[nvm](https://github.com/creationix/nvm/blob/master/README.md){rel="noopener"} - популярный способ запуска Node.js. Он позволяет легко менять версию Node.js, устанавливать новые версии, чтобы попробовать и легко откатиться назад, если, например, что-то сломается.

Это также очень полезно для тестирования вашего кода со старыми версиями Node.js.

Я рекомендую использовать официальную программу установки, если вы только начинаете и еще не используете Homebrew. В противном случае Homebrew - мое любимое решение.

### Сколько JavaScript нужно знать, чтобы использовать Node.js? {#how-much-javascript-do-you-need-to-know-to-use-node-js}

Если вы только начинаете изучать JavaScript, насколько глубоко вам нужно знать язык?

Новичку трудно достичь того момента, когда вы будете достаточно уверены в своих способностях программиста.

Изучая язык, вы также можете запутаться, где заканчивается JavaScript и начинается Node.js, и наоборот.

Я бы рекомендовал вам хорошо усвоить основные концепции JavaScript, прежде чем погружаться в Node.js:

- Лексическая структура
- Выражения
- Типы
- Переменные
- Функции
- этот
- Стрелочные функции
- Циклы
- Циклы и область видимости
- Массивы
- Шаблонные литералы
- Точки с запятой
- Строгий режим
- ECMAScript 6, 2016, 2017

Зная эти понятия, вы уже на пути к тому, чтобы стать опытным разработчиком JavaScript как в браузере, так и в Node.js.

Следующие концепции также являются ключевыми для понимания асинхронного программирования, которое является одной из фундаментальных составляющих Node.js:

- Асинхронное программирование и обратные вызовы
- Таймеры
- Обещания
- Асинхронность и ожидание
- Закрытия
- Цикл событий

К счастью, я написал бесплатную электронную книгу, которая объясняет все эти темы, и называется она [JavaScript Fundamentals](https://flaviocopes.com/javascript/){rel="noopener"}. Это самый компактный ресурс, который вы сможете найти для изучения всего этого.

### Различия между Node.js и браузером {#differences-between-node-js-and-the-browser}

Чем написание JavaScript-приложений в Node.js отличается от программирования для Web в браузере.

И браузер, и Node используют JavaScript в качестве языка программирования.

Создание приложений, работающих в браузере, - это совершенно другое дело, чем создание приложения в Node.js.

Несмотря на то, что это всегда JavaScript, есть несколько ключевых различий, которые делают опыт радикально другим.

У front-end разработчика, который пишет приложения на Node.js, есть огромное преимущество - язык все тот же.

У вас есть огромная возможность, потому что мы знаем, как трудно полностью, глубоко изучить язык программирования. Используя один и тот же язык для выполнения всей работы в Интернете - как на клиенте, так и на сервере - вы находитесь в уникальном положении преимущества.

Что меняется, так это экосистема.

В браузере большую часть времени вы взаимодействуете с DOM или другими API веб-платформы, такими как Cookies. В Node.js их, конечно, не существует. У вас нет `document`, `window` и всех остальных объектов, предоставляемых браузером.

И в браузере у нас нет всех тех приятных API, которые Node.js предоставляет через свои модули, например, функции доступа к файловой системе.

Еще одно большое различие заключается в том, что в Node.js вы контролируете среду. Если только вы не создаете приложение с открытым исходным кодом, которое каждый может развернуть где угодно, вы знаете, на какой версии Node.js вы будете запускать приложение. По сравнению с браузерной средой, где у вас нет возможности выбирать, какой браузер будут использовать ваши посетители, это очень удобно.

Это означает, что вы можете писать все современные ES6--7--8--9 JavaScript, которые поддерживает ваша версия Node.

Поскольку JavaScript развивается так быстро, но браузеры могут быть немного медленными, а пользователи немного медлят с обновлением - иногда в Интернете вы застреваете в использовании старых версий JavaScript/ECMAScript.

Вы можете использовать Babel для преобразования вашего кода в ES5-совместимый перед отправкой его в браузер, но в Node.js вам это не понадобится.

Еще одно отличие заключается в том, что в Node.js используется система модулей [CommonJS](https://flaviocopes.com/commonjs/){rel="noopener"}, в то время как в браузере мы начинаем видеть внедрение стандарта ES Modules.

На практике это означает, что пока что вы используете `require()` в Node.js и `import` в браузере.

### Движок JavaScript V8

V8 - это название движка JavaScript, на котором работает Google Chrome. Именно он принимает наш JavaScript и выполняет его во время просмотра веб-страниц в Chrome.

V8 обеспечивает среду выполнения, в которой выполняется JavaScript. DOM и другие API веб-платформы предоставляются браузером.

Самое интересное, что движок JavaScript не зависит от браузера, в котором он размещен. Эта ключевая особенность обеспечила подъем Node.js. Движок V8 был выбран Node.js еще в 2009 году, и по мере роста популярности Node.js, V8 стал тем движком, на котором сейчас работает невероятное количество кода на стороне сервера, написанного на JavaScript.

Экосистема Node.js огромна, и благодаря ей V8 также используется в приложениях для настольных компьютеров, в таких проектах, как [Electron](https://electronjs.org/){rel="noopener"}.

#### Другие движки JS

Другие браузеры имеют свой собственный движок JavaScript:

- Firefox имеет [Spidermonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey){rel="noopener"}.
- Safari имеет [JavaScriptCore](https://developer.apple.com/documentation/javascriptcore){rel="noopener"} (также называется Nitro)
- Edge имеет [Chakra](https://github.com/Microsoft/ChakraCore){rel="noopener"}

и многие другие.

Все эти движки реализуют стандарт ECMA ES-262, также называемый ECMAScript, стандарт, используемый в JavaScript.

#### Стремление к производительности

V8 написан на C++ и постоянно совершенствуется. Он переносимый и работает на Mac, Windows, Linux и некоторых других системах.

В этом введении в V8 я буду игнорировать детали реализации V8. Их можно найти на более авторитетных сайтах, включая [официальный сайт V8](https://developers.google.com/v8/){rel="noopener"}, и они меняются со временем, часто радикально.

V8 постоянно развивается, как и другие движки JavaScript, чтобы ускорить работу Сети и экосистемы Node.js.

В Интернете существует гонка за производительностью, которая продолжается уже много лет, и мы (как пользователи и разработчики) получаем большую выгоду от этой конкуренции, поскольку год за годом получаем более быстрые и оптимизированные машины.

#### Компиляция

JavaScript принято считать интерпретируемым языком, но современные движки JavaScript уже не просто интерпретируют JavaScript, они его компилируют.

Это происходит с 2009 года, когда компилятор SpiderMonkey JavaScript был добавлен в Firefox 3.5, и все последовали этой идее.

JavScript компилируется внутри V8 с помощью компиляции just-in-time (JIT) для ускорения выполнения.

Это может показаться неинтуитивным. Но с момента появления Google Maps в 2004 году JavaScript превратился из языка, который обычно выполнял несколько десятков строк кода, в полноценные приложения с тысячами и сотнями тысяч строк, работающие в браузере.

Теперь наши приложения могут часами работать в браузере, а не быть просто несколькими правилами проверки форм или простыми скриптами.

В этом **новом мире** компиляция JavaScript имеет смысл, потому что, хотя на подготовку JavaScript **готового** кода может потребоваться немного больше времени, он будет гораздо более производительным, чем чисто интерпретируемый код.

### Как выйти из программы Node.js {#how-to-exit-from-a-node-js-program}

Существуют различные способы завершения работы приложения Node.js.

При запуске программы в консоли вы можете закрыть ее с помощью `ctrl-C`, но то, что я хочу обсудить здесь, это программный выход.

Давайте начнем с самого радикального варианта и посмотрим, почему его лучше **не использовать**.

Основной модуль `process` предоставляет удобный метод, который позволяет вам программно выйти из программы Node.js: `process.exit()`.

Когда Node.js выполняет эту строку, процесс немедленно завершается.

Это означает, что любой ожидающий обратный вызов, любой сетевой запрос, который все еще отправляется, любой доступ к файловой системе или процессы, пишущие в `stdout` или `stderr` --- все это будет немедленно безболезненно завершено.

Если вас это устраивает, вы можете передать целое число, которое сообщит операционной системе код завершения:

```language-js
process.exit(1)
```

По умолчанию код выхода равен `0`, что означает успех. Различные коды выхода имеют разное значение, которое вы можете использовать в своей системе, чтобы программа могла общаться с другими программами.

Подробнее о кодах выхода вы можете прочитать [здесь](https://nodejs.org/api/process.html#process_exit_codes){rel="noopener"}.

Вы также можете установить свойство `process.exitCode`:

```language-js
process.exitCode = 1
```

и когда программа впоследствии завершится, Node.js вернет этот код выхода.

Программа изящно завершится, когда вся обработка будет закончена.

Много раз с помощью Node.js мы запускаем серверы, например, этот HTTP-сервер:

```language-js
const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('Hi!')
})

app.listen(3000, () => console.log('Server ready'))
```

Эта программа никогда не завершится. Если вы вызовете `process.exit()`, любой ожидающий или выполняющийся запрос будет прерван. Это **нехорошо**.

В этом случае вам нужно послать команде сигнал `SIGTERM` и обработать его с помощью обработчика сигнала процесса:

**Примечание:** `process` не требует `require`, он автоматически доступен.

```language-js
const express = require('express')

const app = express()

app.get('/', (req, res) => {
  res.send('Hi!')
})

const server = app.listen(3000, () => console.log('Server ready'))

process.on('SIGTERM', () => {
  server.close(() => {
    console.log('Process terminated')
  })
})
```

Что такое сигналы? Сигналы - это система обмена данными Portable Operating System Interface (POSIX): уведомление, посылаемое процессу, чтобы оповестить его о произошедшем событии.

`SIGKILL` - это сигнал, который сообщает процессу о немедленном завершении, и в идеале должен действовать подобно `process.exit()`.

`SIGTERM` - это сигнал, который сообщает процессу о необходимости плавного завершения. Это сигнал, который посылается менеджерами процессов, такими как `upstart` или `supervisord` и многими другими.

Вы можете послать этот сигнал изнутри программы, в другой функции:

```language-js
process.kill(process.pid, 'SIGTERM')
```

Или из другой программы, запущенной на Node.js, или из любого другого приложения, запущенного в вашей системе, которое знает PID процесса, который вы хотите завершить.

### Как читать переменные окружения из Node.js {#how-to-read-environment-variables-from-node-js}

Модуль `process` ядра Node предоставляет свойство `env`, в котором хранятся все переменные окружения, которые были установлены в момент запуска процесса.

Вот пример, который обращается к переменной окружения `NODE_ENV`, которая по умолчанию установлена в `development`.

```language-js
process.env.NODE_ENV // "development"
```

Установив ее в `production` перед запуском сценария, вы сообщите Node.js, что это производственная среда.

Таким же образом вы можете получить доступ к любой пользовательской переменной окружения, которую вы установили.

Здесь мы задали 2 переменные для API_KEY и API_SECRET

```language-js
API_KEY=123123 API_SECRET=456456 node app.js
```

Мы можем получить их в Node.js, выполнив команду

```language-js
process.env.API_KEY // "123123"
process.env.API_SECRET // "456456"
```

Вы можете записать переменные окружения в файл `.env` (который следует добавить в `.gitignore`, чтобы избежать публикации на GitHub), затем

    npm install dotenv

и в начале вашего основного файла Node добавьте

```language-js
require('dotenv').config()
```

Таким образом, вы можете не указывать переменные окружения в командной строке перед командой `node`, и эти переменные будут подхвачены автоматически.

**Примечание:** Некоторые инструменты, например, Next.js, делают переменные окружения, определенные в `.env`, автоматически доступными без необходимости использования `dotenv`.

### Где разместить приложение Node.js {#where-to-host-a-node-js-app}

Приложение Node.js может быть размещено во многих местах, в зависимости от ваших потребностей.

Вот неполный список вариантов, которые вы можете рассмотреть, когда захотите развернуть свое приложение и сделать его общедоступным.

Я буду перечислять варианты от самых простых и ограниченных к более сложным и мощным.

#### Самый простой вариант: локальный туннель.

Даже если у вас динамический IP или вы находитесь под NAT, вы можете развернуть свое приложение и обслуживать запросы прямо со своего компьютера, используя локальный туннель.

Этот вариант подходит для быстрого тестирования, демонстрации продукта или совместного использования приложения с очень небольшой группой людей.

Очень хорошим инструментом для этого, доступным на всех платформах, является [ngrok](https://ngrok.com/){rel="noopener"}.

Используя его, вы можете просто набрать `ngrok PORT` и нужный вам PORT будет открыт для интернета. Вы получите домен ngrok.io, но при платной подписке вы можете получить пользовательский URL, а также больше возможностей безопасности (помните, что вы открываете свою машину для публичного Интернета).

Еще один сервис, который вы можете использовать, - [localtunnel](https://github.com/localtunnel/localtunnel){rel="noopener"}.

#### Развертывание нулевой конфигурации

#### Глюк

[Glitch](https://glitch.com/){rel="noopener"} - это игровая площадка и способ создавать свои приложения быстрее, чем когда-либо, и видеть их в реальном времени на собственном поддомене glitch.com. В настоящее время вы не можете иметь собственный домен, и есть несколько [ограничений](https://glitch.com/faq#restrictions){rel="noopener"}, но это действительно здорово для создания прототипов. Он выглядит забавно (и это плюс), и это не отупляющая среда - вы получаете всю мощь Node.js, CDN, безопасное хранение учетных данных, импорт/экспорт GitHub и многое другое.

Предоставляется компанией, стоящей за FogBugz и Trello (и соавторами Stack Overflow).

Я часто использую его в демонстрационных целях.

#### Codepen

[Codepen](https://codepen.io/){rel="noopener"} - это удивительная платформа и сообщество. Вы можете создать проект с несколькими файлами и развернуть его с помощью пользовательского домена.

#### Serverless

Способ публикации приложений и отсутствие сервера для управления - это Serverless. Serverless - это парадигма, в которой вы публикуете свои приложения как **функции**, а они отвечают на запросы конечной точки сети (также называемой FAAS --- Functions As A Service).

К очень популярным решениям относятся:

- [Serverless Framework](https://serverless.com/framework/){rel="noopener"}
- [Стандартная библиотека](https://stdlib.com/){rel="noopener"}.

Они оба предоставляют слой абстракции для публикации на AWS Lambda и других FAAS-решений на базе Azure или Google Cloud.

#### PAAS

PAAS расшифровывается как Platform As A Service. Эти платформы убирают многие вещи, о которых вы должны беспокоиться при развертывании вашего приложения.

#### Zeit Now

[Zeit](https://zeit.co/now){rel="noopener"} - интересный вариант. Вы просто вводите `now` в терминале, и он берет на себя заботу о развертывании вашего приложения. Есть бесплатная версия с ограничениями, а платная версия более мощная. Вы просто забываете о существовании сервера, вы просто развертываете приложение.

#### Nanobox

[Nanobox](https://nanobox.io/){rel="noopener"}.

#### Heroku

[Heroku](https://www.heroku.com/){rel="noopener"} - удивительная платформа.

Это отличная статья о [начале работы с Node.js на Heroku](https://devcenter.heroku.com/articles/getting-started-with-node){rel="noopener"}.

#### Microsoft Azure

[Azure](https://azure.microsoft.com/en-us/){rel="noopener"} - это облачное предложение Microsoft.

Посмотрите, как [создать веб-приложение Node.js в Azure](https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-node){rel="noopener"}.

#### Google Cloud Platform

[Google Cloud](https://cloud.google.com/){rel="noopener"} - это удивительная структура для ваших приложений.

У них есть хороший [Раздел документации по Node.js](https://cloud.google.com/node/){rel="noopener"}.

#### Виртуальный выделенный сервер

В этом разделе вы найдете обычных подозреваемых, упорядоченных от более удобных для пользователя к менее удобным:

- [Digital Ocean](https://www.digitalocean.com/){rel="noopener"}
- [Linode](https://www.linode.com/){rel="noopener"}
- [Amazon Web Services](https://aws.amazon.com/){rel="noopener"}, в частности, я упоминаю Amazon Elastic Beanstalk, поскольку он немного абстрагирует сложность AWS.

Поскольку они предоставляют пустую Linux-машину, на которой вы можете работать, специального руководства по ним нет.

Есть много других вариантов в категории VPS, это только те, которые я использовал и рекомендую.

#### Bare metal

Другим решением является получение [bare metal сервера](https://en.wikipedia.org/wiki/Bare-metal_server){rel="noopener"}, установка дистрибутива Linux, подключение к интернету (или аренда сервера на месяц, как это можно сделать с помощью сервиса [Vultr Bare Metal](https://www.vultr.com/pricing/baremetal/){rel="noopener"}).

### Как использовать Node.js REPL {#how-to-use-the-node-js-repl}

REPL расшифровывается как Read-Evaluate-Print-Loop, и это отличный способ быстро изучить возможности Node.js.

Команда `node` - это команда, которую мы используем для запуска наших скриптов Node.js:

    node script.js

Если мы опускаем имя файла, мы используем его в режиме REPL:

    node

Если вы попробуете сделать это сейчас в терминале, вот что произойдет:

    ❯ node
    >

команда остается в режиме ожидания и ждет, пока мы что-нибудь введем.

**Совет**: если вы не знаете, как открыть терминал, наберите в Google "How to open terminal on \<ваша операционная система\>".

REPL ждет, пока мы введем какой-нибудь код JavaScript.

Начните с простого и введите:

    > console.log('test')
    test
    undefined
    >

Первое значение, `test`, - это вывод, который мы сказали консоли вывести, затем мы получаем undefined, которое является возвращаемым значением выполнения `console.log()`.

Теперь мы можем ввести новую строку JavaScript.

#### Использование вкладки для автозаполнения

Самое замечательное в REPL то, что он интерактивен.

По мере написания кода, если вы нажмете клавишу `tab`, REPL попытается автозаполнить то, что вы написали, чтобы соответствовать переменной, которую вы уже определили, или предопределенной переменной.

#### Изучение объектов JavaScript

Попробуйте ввести имя класса JavaScript, например `Number`, добавить точку и нажать `tab`.

REPL выведет все свойства и методы этого класса, к которым вы можете получить доступ:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/MgYHCtgjD1rom1yKM43E-qBh7ansJuyglRWr"
class="kg-image" loading="lazy" width="800" height="457"
alt="MgYHCtgjD1rom1yKM43E-qBh7ansJuyglRWr" />
</figure>

#### Исследуйте глобальные объекты

Вы можете просмотреть глобальные объекты, к которым у вас есть доступ, набрав `global.` и нажав `tab`:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/e2qWLuyjYC4DFZjEs2jYWK-NL9AXbpDiSdA7"
class="kg-image" loading="lazy" width="800" height="733"
alt="e2qWLuyjYC4DFZjEs2jYWK-NL9AXbpDiSdA7" />
</figure>

#### Специальная переменная \_

Если после некоторого кода вы напечатаете `_`, то будет выведен результат последней операции.

#### Команды с точкой

В REPL есть несколько специальных команд, все они начинаются с точки `.`. К ним относятся

- `.help`: показывает справку по точечным командам.
- `.editor`: включает режим редактора, позволяющий легко писать многострочный код JavaScript. Как только вы окажетесь в этом режиме, введите ctrl-D, чтобы запустить написанный вами код.
- `.break`: при вводе многострочного выражения ввод команды .break прерывает дальнейший ввод. Аналогично нажатию клавиши ctrl-C.
- `.clear`: сбрасывает контекст REPL на пустой объект и очищает любое многострочное выражение, вводимое в данный момент.
- `.load`: загружает файл JavaScript, относительно текущего рабочего каталога.
- `.save`: сохраняет все, что вы ввели в сеансе REPL, в файл (укажите имя файла).
- `.exit`: завершает работу (то же самое, что два раза нажать ctrl-C).

REPL знает, когда вы набираете многострочный оператор, без необходимости вызывать `.editor`.

Например, если вы начинаете набирать итерацию следующим образом:

```language-js
[1, 2, 3].forEach(num => {
```

и вы нажмете `enter`, REPL перейдет на новую строку, начинающуюся с 3 точек, указывая, что теперь вы можете продолжить работу над этим блоком.

```language-js
...   console.log(num)
... })
```

Если вы напечатаете `.break` в конце строки, многострочный режим остановится и утверждение не будет выполнено.

### Node.js, принимать аргументы из командной строки {#node-js-accept-arguments-from-the-command-line}

Как принимать аргументы в программе Node.js, передаваемые из командной строки

Вы можете передавать любое количество аргументов при вызове приложения Node.js с помощью:

    node app.js

Аргументы могут быть отдельными или иметь ключ и значение.

Например:

    node app.js flavio

или

    node app.js name=flavio

Это меняет способ получения этого значения в коде Node.js.

Для его получения используется объект `process`, встроенный в Node.js.

Он раскрывает свойство `argv`, которое представляет собой массив, содержащий все аргументы командной строки.

Первый аргумент - это полный путь команды `node`.

Второй элемент - полный путь выполняемого файла.

Все дополнительные аргументы присутствуют с третьей позиции и далее.

Вы можете перебирать все аргументы (включая путь к узлу и путь к файлу) с помощью цикла:

```language-js
process.argv.forEach((val, index) => {
  console.log(`${index}: ${val}`)
})
```

Вы можете получить только дополнительные аргументы, создав новый массив, исключающий первые 2 параметра:

```language-js
const args = process.argv.slice(2)
```

Если у вас есть один аргумент без имени индекса, например, так:

    node app.js flavio

вы можете получить к нему доступ, используя

```language-js
const args = process.argv.slice(2)
args[0]
```

В данном случае:

    node app.js name=flavio

`args[0]` - это `name=flavio`, и вам нужно разобрать его. Лучший способ сделать это - использовать `minimist` [library](https://www.npmjs.com/package/minimist){rel="noopener"}, который помогает работать с аргументами:

```language-js
const args = require('minimist')(process.argv.slice(2))
args['name'] // flavio
```

### Вывод в командную строку с помощью Node.js {#output-to-the-command-line-using-node-js}

Как выводить в консоль командной строки с помощью Node.js, от базового console.log до более сложных сценариев.

#### Базовый вывод с помощью модуля консоли

Node.js предоставляет `console` [модуль](https://nodejs.org/api/console.html){rel="noopener"}, который обеспечивает множество очень полезных способов взаимодействия с командной строкой.

По сути, это то же самое, что и объект `console`, который можно найти в браузере.

Самым основным и наиболее используемым методом является `console.log()`, который печатает строку, которую вы передаете в консоль.

Если вы передадите объект, он будет отображен как строка.

В `console.log` можно передать несколько переменных, например:

```language-js
const x = 'x'
const y = 'y'
console.log(x, y)
```

и Node.js выведет обе фразы.

Мы также можем форматировать красивые фразы, передавая переменные и спецификатор формата.

Например:

```language-js
console.log('My %s has %d years', 'cat', 2)
```

- `%s` форматирует переменную как строку
- `%d` или `%i` форматируют переменную как целое число
- `%f` форматирует переменную как число с плавающей точкой
- `%O` используется для печати представления объекта

Пример:

```language-js
console.log('%O', Number)
```

#### Очистить консоль

`console.clear()` очищает консоль (поведение может зависеть от используемой консоли).

#### Подсчет элементов

`console.count()` - удобный метод.

Возьмите этот код:

```language-js
const x = 1
const y = 2
const z = 3

console.count(
  'The value of x is ' + x + ' and has been checked .. how many times?'
)

console.count(
  'The value of x is ' + x + ' and has been checked .. how many times?'
)

console.count(
  'The value of y is ' + y + ' and has been checked .. how many times?'
)
```

Происходит это так: `count` будет считать, сколько раз печатается строка, и выводить рядом с ней счет.

Вы можете просто считать яблоки и апельсины:

```language-js
const oranges = ['orange', 'orange']
const apples = ['just one apple']

oranges.forEach(fruit => {
  console.count(fruit)
})

apples.forEach(fruit => {
  console.count(fruit)
})
```

#### Печать трассировки стека

Бывают случаи, когда полезно распечатать трассировку стека вызовов функции, возможно, чтобы ответить на вопрос: "Как вы достигли этой части кода?".

Вы можете сделать это с помощью `console.trace()`:

```language-js
const function2 = () => console.trace()
const function1 = () => function2()
function1()
```

Это выведет трассировку стека. Вот что будет выведено, если я попробую сделать это в Node REPL:

    Trace
      at function2 (repl:1:33)
      at function1 (repl:1:25)
      at repl:1:1
      at ContextifyScript.Script.runInThisContext (vm.js:44:33)
      at REPLServer.defaultEval (repl.js:239:29)
      at bound (domain.js:301:14)
      at REPLServer.runBound [as eval] (domain.js:314:12)
      at REPLServer.onLine (repl.js:440:10)
      at emitOne (events.js:120:20)
      at REPLServer.emit (events.js:210:7)

#### Вычислите затраченное время

Вы можете легко подсчитать, сколько времени занимает выполнение функции, используя `time()` и `timeEnd()`.

```language-js
const doSomething = () => console.log('test')
const measureDoingSomething = () => {
  console.time('doSomething()')
  // do something, and measure the time it takes
  doSomething()
  console.timeEnd('doSomething()')
}

measureDoingSomething()
```

#### stdout и stderr

Как мы видели, console.log отлично подходит для печати сообщений в консоли. Это то, что называется стандартным выводом, или `stdout`.

Ошибка `console.error` печатается в поток `stderr`.

Он не появится в консоли, но появится в журнале ошибок.

#### Цвет вывода

Вы можете раскрасить выводимый в консоль текст, используя управляющие последовательности. Эскейп-последовательность - это набор символов, идентифицирующих цвет.

Пример:

```language-js
console.log('\x1b[33m%s\x1b[0m', 'hi!')
```

Вы можете попробовать сделать это в Node REPL, и он выведет `hi!` желтым цветом.

Однако это низкоуровневый способ сделать это. Самый простой способ раскрасить вывод консоли - это использовать библиотеку. [Chalk](https://github.com/chalk/chalk){rel="noopener"} является такой библиотекой, и в дополнение к раскрашиванию она также помогает с другими средствами стилизации, например, делает текст жирным, курсивным или подчеркнутым.

Вы устанавливаете ее с помощью `npm install chalk`, а затем можете использовать ее:

```language-js
const chalk = require('chalk')
console.log(chalk.yellow('hi!'))
```

Использовать `chalk.yellow` гораздо удобнее, чем пытаться запомнить escape-коды, и код становится гораздо более читабельным.

Проверьте ссылку на проект, которую я разместил выше, чтобы найти больше примеров использования.

#### Создание индикатора выполнения

[Progress](https://www.npmjs.com/package/progress){rel="noopener"} - это замечательный пакет для создания прогресс-бара в консоли. Установите его с помощью `npm install progress`.

Этот фрагмент создает 10-шаговый прогресс-бар, и каждые 100 мс завершается один шаг. Когда полоса завершается, мы очищаем интервал:

```language-js
const ProgressBar = require('progress')

const bar = new ProgressBar(':bar', { total: 10 })
const timer = setInterval(() => {
  bar.tick()
  if (bar.complete) {
    clearInterval(timer)
  }
}, 100)
```

### Принять ввод из командной строки в Node.js {#accept-input-from-the-command-line-in-node-js}

Как сделать программу Node.js CLI интерактивной?

Node, начиная с версии 7, предоставляет `readline` [модуль](https://nodejs.org/api/readline.html){rel="noopener"} для выполнения именно этого: получения ввода из читаемого потока, такого как поток `process.stdin`, который во время выполнения программы Node является вводом терминала, по одной строке за раз.

```language-js
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
})

readline.question(`What's your name?`, (name) => {
  console.log(`Hi ${name}!`)
  readline.close()
})
```

Этот фрагмент кода запрашивает имя пользователя, и как только текст будет введен и пользователь нажмет клавишу Enter, мы отправим приветствие.

Метод `question()` показывает первый параметр (вопрос) и ожидает ввода пользователем. Он вызывает функцию обратного вызова после нажатия клавиши Enter.

В этой функции обратного вызова мы закрываем интерфейс readline.

`readline` предлагает несколько других методов, и я позволю вам ознакомиться с ними в документации по пакету, ссылку на которую я привел выше.

Если вам нужно потребовать пароль, лучше всего теперь выводить его обратно эхом, а вместо него показывать символ `*`.

Самый простой способ - использовать readline-sync [package](https://www.npmjs.com/package/readline-sync){rel="noopener"}, который очень похож по API и справляется с этим из коробки.

Более полное и абстрактное решение предоставляет пакет [Inquirer.js](https://github.com/SBoudrias/Inquirer.js){rel="noopener"}.

Вы можете установить его с помощью `npm install inquirer`, а затем воспроизвести приведенный выше код следующим образом:

```language-js
const inquirer = require('inquirer')

var questions = [{
  type: 'input',
  name: 'name',
  message: "What's your name?",
}]

inquirer.prompt(questions).then(answers => {
  console.log(`Hi ${answers['name']}!`)
})
```

Inquirer.js позволяет вам делать множество вещей, например, задавать несколько вариантов ответа, иметь радиокнопки, подтверждения и многое другое.

Стоит знать все альтернативы, особенно встроенные, предоставляемые Node.js, но если вы планируете вывести CLI-ввод на новый уровень, Inquirer.js - оптимальный выбор.

### Выявление функциональности из файла Node.js с помощью экспорта {#expose-functionality-from-a-node-js-file-using-exports}

Как использовать API `module.exports` для передачи данных в другие файлы вашего приложения или в другие приложения.

Node.js имеет встроенную систему модулей.

Файл Node.js может импортировать функциональность, открытую другими файлами Node.js.

Когда вы хотите импортировать что-то, вы используете:

```language-js
const library = require('./library')
```

для импорта функциональности, раскрытой в файле `library.js`, который находится в папке текущего файла.

В этом файле функциональность должна быть раскрыта, прежде чем она может быть импортирована другими файлами.

Любой другой объект или переменная, определенные в файле, по умолчанию являются приватными и не раскрываются внешнему миру.

Именно это позволяет сделать API `module.exports`, предлагаемый `module` [system](https://nodejs.org/api/modules.html){rel="noopener"}.

Когда вы назначаете объект или функцию в качестве нового свойства `exports`, это и есть то, что раскрывается. Как таковой, он может быть импортирован в другие части вашего приложения или в другие приложения.

Вы можете сделать это двумя способами.

Первый - присвоить объект свойству `module.exports`, которое является объектом, предоставляемым из коробки системой модулей, и это заставит ваш файл экспортировать **только этот объект**:

```language-js
const car = {
  brand: 'Ford',
  model: 'Fiesta'
}

module.exports = car

// ...in the other file

const car = require('./car')
```

Второй способ - добавить экспортируемый объект в качестве свойства `exports`. Этот способ позволяет экспортировать **множество** объектов, функций или данных:

```language-js
const car = {
  brand: 'Ford',
  model: 'Fiesta'
}

exports.car = car
```

или непосредственно

```language-js
exports.car = {
  brand: 'Ford',
  model: 'Fiesta'
}
```

А в другом файле вы будете использовать его, ссылаясь на свойство вашего импорта:

```language-js
const items = require('./items')
items.car
```

или

```language-js
const car = require('./items').car
```

В чем разница между `module.exports` и `exports`?

Первый раскрывает **объект**, на который он указывает. Второй раскрывает **свойства** объекта, на который он указывает.

### Введение в npm

`npm` означает **менеджер пакетов узла**.

В январе 2017 года в реестре npm было зарегистрировано более 350 000 пакетов, что делает его самым большим хранилищем кода на одном языке на Земле, и вы можете быть уверены, что здесь есть пакет для (почти!) всего.

Он начинался как способ загрузки и управления зависимостями пакетов Node.js, но с тех пор стал инструментом, используемым и в front-end JavaScript.

Есть много вещей, которые делает `npm`.

#### Загрузка

`npm` управляет загрузкой зависимостей вашего проекта.

#### Установка всех зависимостей

Если в проекте есть файл `packages.json`, то, выполнив команду

    npm install

установит все, что нужно проекту, в папку `node_modules`, создав ее, если она еще не существует.

#### Установка одного пакета

Вы также можете установить определенный пакет, выполнив команду

    npm install <package-name>

Часто можно увидеть дополнительные флаги, добавляемые к этой команде:

- `--save` устанавливает и добавляет запись в файл `package.json` `dependencies`.
- `--save-dev` устанавливает и добавляет запись в файл `package.json` `devDependencies`.

Разница в основном заключается в том, что `devDependencies` обычно являются инструментами разработки, например, библиотекой для тестирования, в то время как `dependencies` поставляются с приложением в продакшене.

#### Обновление пакетов

Обновление пакетов также упрощается, если выполнить

    npm update

`npm` проверит все пакеты на наличие более новой версии, удовлетворяющей вашим ограничениям по версионности.

Вы также можете указать отдельный пакет для обновления:

    npm update <package-name>

#### Версионирование

Помимо простой загрузки, `npm` также управляет **версионированием**, так что вы можете указать любую конкретную версию пакета или потребовать версию выше или ниже той, которая вам нужна.

Много раз вы можете обнаружить, что библиотека совместима только с основным выпуском другой библиотеки.

Или ошибка в последнем выпуске библиотеки, до сих пор не исправленная, вызывает проблему.

Указание явной версии библиотеки также помогает держать всех на одной и той же точной версии пакета, так что вся команда работает с одной и той же версией до тех пор, пока файл `package.json` не будет обновлен.

Во всех этих случаях версионирование очень помогает, и `npm` следует стандарту семантического версионирования (semver).

#### Выполняемые задачи

Файл package.json поддерживает формат для указания задач командной строки, которые могут быть запущены с помощью команды

    npm run <task-name>

Например:

```language-json
{
  "scripts": {
    "start-dev": "node lib/server-development",
    "start": "node lib/server-production"
  },
}
```

Очень часто эта функция используется для запуска Webpack:

```language-json
{
  "scripts": {
    "watch": "webpack --watch --progress --colors --config webpack.conf.js",
    "dev": "webpack --progress --colors --config webpack.conf.js",
    "prod": "NODE_ENV=production webpack -p --config webpack.conf.js",
  },
}
```

Поэтому вместо того, чтобы набирать эти длинные команды, которые легко забыть или напечатать неправильно, вы можете выполнить

    $ npm watch
    $ npm dev
    $ npm prod

### Куда npm устанавливает пакеты?

Когда вы устанавливаете пакет с помощью `npm` (или [yarn](https://flaviocopes.com/yarn/){rel="noopener"}), вы можете выполнить 2 типа установки:

- локальная установка
- глобальная установка

По умолчанию, когда вы вводите команду `npm install`, например:

    npm install lodash

пакет устанавливается в текущее дерево файлов, в подпапку `node_modules`.

При этом `npm` также добавляет запись `lodash` в свойство `dependencies` файла `package.json`, находящегося в текущей папке.

Глобальная установка выполняется с помощью флага `-g`:

    npm install -g lodash

Когда это происходит, npm не будет устанавливать пакет в локальную папку, а вместо этого будет использовать глобальное расположение.

Где именно?

Команда `npm root -g` скажет вам, где именно находится это место на вашей машине.

На macOS или Linux это место может быть `/usr/local/lib/node_modules`. В Windows это может быть `C:\Users\YOU\AppData\Roaming\npm\node_modules`.

Если вы используете `nvm` для управления версиями Node.js, однако, это расположение будет отличаться.

Я, например, использую `nvm` и расположение моих пакетов было показано как `/Users/flavio/.nvm/versions/node/v8.9.0/lib/node_modules`.

### Как использовать или выполнить пакет, установленный с помощью npm

#### Как включить и использовать в коде пакет, установленный в папке node_modules.

Когда вы устанавливаете с помощью `npm` пакет в папку `node_modules` или глобально, как вы используете его в своем коде Node?

Скажем, вы устанавливаете `lodash`, популярную библиотеку утилит JavaScript, используя

    npm install lodash

Это позволит установить пакет в локальную папку `node_modules`.

Чтобы использовать его в своем коде, вам просто нужно импортировать его в свою программу с помощью `require`:

```language-js
const _ = require('lodash')
```

Что если ваш пакет является исполняемым файлом?

В этом случае он поместит исполняемый файл в папку `node_modules/.bin/`.

Один из простых способов продемонстрировать это - [cowsay](https://www.npmjs.com/package/cowsay){rel="noopener"}.

Пакет cowsay предоставляет программу командной строки, которая может быть выполнена, чтобы заставить корову сказать что-нибудь (и других животных тоже).

Когда вы устанавливаете пакет с помощью `npm install cowsay`, он установит себя и несколько зависимостей в папку node_modules.

Там есть скрытая папка .bin, которая содержит символические ссылки на двоичные файлы cowsay.

Как их выполнить?

Конечно, вы можете набрать `./node_modules/.bin/cowsay`, чтобы запустить его, и это работает, но [npx](https://flaviocopes.com/npx/){rel="noopener"}, включенный в последние версии npm (начиная с 5.2), является гораздо лучшим вариантом. Вы просто запускаете:

    npx cowsay

и npx найдет местоположение пакета.

### Руководство по пакету.json {#the-package-json-guide}

Файл package.json является ключевым элементом во многих кодовых базах приложений, основанных на экосистеме Node.js.

Если вы работаете с JavaScript или когда-либо взаимодействовали с проектом JavaScript, Node.js или front-end проектом, вы наверняка встречали файл `package.json`.

Для чего он нужен? Что вы должны знать о нем, и какие интересные вещи вы можете с ним делать?

Файл `package.json` - это своего рода манифест вашего проекта. Он может делать множество вещей, совершенно не связанных между собой. Например, это центральное хранилище конфигурации для инструментов. В нем также хранятся имена и версии установленных пакетов [`npm`](https://flaviocopes.com/npm/){rel="noopener"} и [`yarn`](https://flaviocopes.com/yarn/){rel="noopener"}.

#### Структура файла

Вот пример файла package.json:

```language-json
{

}
```

Он пустой! Не существует фиксированных требований к тому, что должно быть в файле `package.json` для приложения. Единственное требование - это соблюдение формата JSON, иначе он не может быть прочитан программами, которые пытаются получить доступ к его свойствам программно.

Если вы создаете пакет Node.js, который вы хотите распространять через `npm`, ситуация радикально меняется, и вы должны иметь набор свойств, которые помогут другим людям использовать его. Подробнее об этом мы поговорим позже.

Это еще один package.json:

```language-json
{
  "name": "test-project"
}
```

Он определяет свойство `name`, которое сообщает имя приложения или пакета, содержащегося в той же папке, где находится этот файл.

Вот гораздо более сложный пример, который я извлек из примера приложения Vue.js:

```language-json
{
  "name": "test-project",
  "version": "1.0.0",
  "description": "A Vue.js project",
  "main": "src/main.js",
  "private": true,
  "scripts": {
    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
    "start": "npm run dev",
    "unit": "jest --config test/unit/jest.conf.js --coverage",
    "test": "npm run unit",
    "lint": "eslint --ext .js,.vue src test/unit",
    "build": "node build/build.js"
  },
  "dependencies": {
    "vue": "^2.5.2"
  },
  "devDependencies": {
    "autoprefixer": "^7.1.2",
    "babel-core": "^6.22.1",
    "babel-eslint": "^8.2.1",
    "babel-helper-vue-jsx-merge-props": "^2.0.3",
    "babel-jest": "^21.0.2",
    "babel-loader": "^7.1.1",
    "babel-plugin-dynamic-import-node": "^1.2.0",
    "babel-plugin-syntax-jsx": "^6.18.0",
    "babel-plugin-transform-es2015-modules-commonjs": "^6.26.0",
    "babel-plugin-transform-runtime": "^6.22.0",
    "babel-plugin-transform-vue-jsx": "^3.5.0",
    "babel-preset-env": "^1.3.2",
    "babel-preset-stage-2": "^6.22.0",
    "chalk": "^2.0.1",
    "copy-webpack-plugin": "^4.0.1",
    "css-loader": "^0.28.0",
    "eslint": "^4.15.0",
    "eslint-config-airbnb-base": "^11.3.0",
    "eslint-friendly-formatter": "^3.0.0",
    "eslint-import-resolver-webpack": "^0.8.3",
    "eslint-loader": "^1.7.1",
    "eslint-plugin-import": "^2.7.0",
    "eslint-plugin-vue": "^4.0.0",
    "extract-text-webpack-plugin": "^3.0.0",
    "file-loader": "^1.1.4",
    "friendly-errors-webpack-plugin": "^1.6.1",
    "html-webpack-plugin": "^2.30.1",
    "jest": "^22.0.4",
    "jest-serializer-vue": "^0.3.0",
    "node-notifier": "^5.1.2",
    "optimize-css-assets-webpack-plugin": "^3.2.0",
    "ora": "^1.2.0",
    "portfinder": "^1.0.13",
    "postcss-import": "^11.0.0",
    "postcss-loader": "^2.0.8",
    "postcss-url": "^7.2.1",
    "rimraf": "^2.6.0",
    "semver": "^5.3.0",
    "shelljs": "^0.7.6",
    "uglifyjs-webpack-plugin": "^1.1.1",
    "url-loader": "^0.5.8",
    "vue-jest": "^1.0.2",
    "vue-loader": "^13.3.0",
    "vue-style-loader": "^3.0.1",
    "vue-template-compiler": "^2.5.2",
    "webpack": "^3.6.0",
    "webpack-bundle-analyzer": "^2.9.0",
    "webpack-dev-server": "^2.9.1",
    "webpack-merge": "^4.1.0"
  },
  "engines": {
    "node": ">= 6.0.0",
    "npm": ">= 3.0.0"
  },
  "browserslist": ["> 1%", "last 2 versions", "not ie <= 8"]
}
```

здесь происходит **много** вещей:

- `name` задает имя приложения/пакета
- `version` указывает текущую версию
- `description` - краткое описание приложения/пакета
- `main` задает точку входа для приложения
- `private`, если установлено значение `true`, предотвращает случайную публикацию приложения/пакета на `npm`.
- `scripts` определяет набор скриптов для node, которые вы можете запускать
- `dependencies` задает список пакетов `npm`, установленных в качестве зависимостей
- `devDependencies` задает список пакетов `npm`, установленных в качестве зависимостей для разработки
- `engines` устанавливает, на каких версиях Node работает этот пакет/приложение
- `browserslist` используется для указания того, какие браузеры (и их версии) вы хотите поддерживать.

Все эти свойства используются либо `npm`, либо другими инструментами, которые мы можем использовать.

#### Разбивка свойств

В этом разделе подробно описаны свойства, которые вы можете использовать. Я ссылаюсь на "пакет", но то же самое относится и к локальным приложениям, которые вы не используете как пакеты.

Большинство из этих свойств используется только на сайте npm [website](https://www.npmjs.com/){rel="noopener"}, другие скриптами, которые взаимодействуют с вашим кодом, например `npm` или другими.

#### `name`.

Устанавливает имя пакета.

Пример:

```language-json
"name": "test-project"
```

Имя должно быть меньше 214 символов, не должно содержать пробелов, может содержать только строчные буквы, дефисы (`-`) или символы подчеркивания (`_`).

Это необходимо потому, что когда пакет публикуется на `npm`, он получает свой собственный URL, основанный на этом свойстве.

Если вы опубликовали этот пакет на GitHub, хорошим значением для этого свойства будет имя репозитория GitHub.

#### `author`.

Перечисляет имя автора пакета.

Пример:

```language-json
{
  "author": "Flavio Copes <flavio@flaviocopes.com> (https://flaviocopes.com)"
}
```

Может также использоваться с этим форматом:

```language-json
{
  "author": {
    "name": "Flavio Copes",
    "email": "your@email.com",
    "url": "https://flaviocopes.com"
  }
}
```

#### `contributors`

Помимо автора, у проекта может быть один или несколько соавторов. Это свойство представляет собой массив, в котором они перечислены.

Пример:

```language-json
{
  "contributors": ["Flavio Copes <your@email.com> (https://flaviocopes.com)"]
}
```

Может также использоваться с этим форматом:

```language-json
{
  "contributors": [
    {
      "name": "Flavio Copes",
      "email": "your@email.com",
      "url": "https://flaviocopes.com"
    }
  ]
}
```

#### `bugs`

Ссылка на трекер проблем пакета, скорее всего, на страницу проблем GitHub

Пример:

```language-json
{
  "bugs": "https://github.com/flaviocopes/package/issues"
}
```

#### `homepage`

Устанавливает домашнюю страницу пакета

Пример:

```language-json
{
  "homepage": "https://flaviocopes.com/package"
}
```

#### `version`

Указывает текущую версию пакета.

Пример:

```language-json
"version": "1.0.0"
```

Это свойство соответствует нотации семантического версионирования (semver) для версий, что означает, что версия всегда выражается 3 числами: `x.x.x`.

Первое число - это основная версия, второе - второстепенная версия, а третье - версия патча.

Эти числа имеют определенный смысл: релиз, который только исправляет ошибки, является патчем, релиз, который вносит обратно совместимые изменения, является минорным релизом, а мажорный релиз может содержать ломающие изменения.

#### `license`.

Указывает лицензию пакета.

Пример:

```language-json
"license": "MIT"
```

#### `keywords`

Это свойство содержит массив ключевых слов, которые ассоциируются с тем, что делает ваш пакет.

Пример:

```language-json
"keywords": [
  "email",
  "machine learning",
  "ai"
]
```

Это поможет людям найти ваш пакет при навигации по похожим пакетам или при просмотре сайта npm.

#### `description`

Это свойство содержит краткое описание пакета.

Пример:

```language-json
"description": "A package to work with strings"
```

Это особенно полезно, если вы решили опубликовать свой пакет в `npm`, чтобы люди могли узнать, о чем этот пакет.

#### `repository`.

Это свойство определяет, где находится репозиторий данного пакета.

Пример:

    "repository": "github:flaviocopes/testing",

Обратите внимание на префикс `github`. Есть и другие популярные сервисы:

```language-json
"repository": "gitlab:flaviocopes/testing",
```

```language-json
"repository": "bitbucket:flaviocopes/testing",
```

Вы можете явно задать систему контроля версий:

```language-json
"repository": {
  "type": "git",
  "url": "https://github.com/flaviocopes/testing.git"
}
```

Вы можете использовать различные системы контроля версий:

```language-json
"repository": {
  "type": "svn",
  "url": "..."
}
```

#### `main`

Устанавливает точку входа для пакета.

Когда вы импортируете этот пакет в приложение, именно здесь приложение будет искать экспорты модуля.

Пример:

```language-json
"main": "src/main.js"
```

#### `private`

если установлено значение `true`, предотвращает случайную публикацию приложения/пакета на `npm`.

Пример:

```language-json
"private": true
```

#### `scripts`

Определяет набор сценариев узла, которые можно запускать.

Пример:

```language-json
"scripts": {
  "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
  "start": "npm run dev",
  "unit": "jest --config test/unit/jest.conf.js --coverage",
  "test": "npm run unit",
  "lint": "eslint --ext .js,.vue src test/unit",
  "build": "node build/build.js"
}
```

Эти скрипты являются приложениями командной строки. Вы можете запустить их, вызвав `npm run XXXX` или `yarn XXXX`, где `XXXX` - имя команды.

Пример:\
`npm run dev`

Вы можете использовать любое имя для команды, а скрипты могут делать буквально все, что угодно.

#### `dependencies`.

Задает список пакетов `npm`, установленных в качестве зависимостей.

Когда вы устанавливаете пакет с помощью npm или yarn:

    npm install <PACKAGENAME>
    yarn add <PACKAGENAME>

этот пакет автоматически вставляется в этот список.

Пример:

```language-json
"dependencies": {
  "vue": "^2.5.2"
}
```

#### `devDependencies`

Задает список пакетов `npm`, установленных в качестве зависимостей для разработки.

Они отличаются от `зависимостей` тем, что предназначены для установки только на машине разработки и не нужны для запуска кода в продакшене.

Когда вы устанавливаете пакет с помощью `npm` или `yarn`:

    npm install --dev <PACKAGENAME>
    yarn add --dev <PACKAGENAME>

этот пакет автоматически вставляется в этот список.

Пример:

```language-json
"devDependencies": {
  "autoprefixer": "^7.1.2",
  "babel-core": "^6.22.1"
}
```

#### `engines`

Устанавливает, на каких версиях Node.js и других команд работает этот пакет/приложение.

Пример:

```language-json
"engines": {
  "node": ">= 6.0.0",
  "npm": ">= 3.0.0",
  "yarn": "^0.13.0"
}
```

#### `browserslist`

Используется для указания того, какие браузеры (и их версии) вы хотите поддерживать. На него ссылаются Babel, Autoprefixer и другие инструменты, чтобы добавлять только те полифиллы и fallbacks, которые необходимы для браузеров, на которые вы ориентируетесь.

Пример:

```language-json
"browserslist": [
  "> 1%",
  "last 2 versions",
  "not ie <= 8"
]
```

Эта конфигурация означает, что вы хотите поддерживать 2 последние основные версии всех браузеров с не менее 1% использования (из статистики [CanIUse.com](https://caniuse.com/){rel="noopener"}), кроме IE8 и ниже ([see more](https://www.npmjs.com/package/browserslist){rel="noopener"} в browserslist).

#### Свойства, специфичные для команды

Файл `package.json` также может содержать специфическую конфигурацию команд, например, для Babel, ESLint и других.

Каждая из них имеет специфическое свойство, например `eslintConfig`, `babel` и другие. Они специфичны для конкретной команды, и вы можете найти, как их использовать, в документации по соответствующей команде/проекту.

#### Версии пакетов

Вы видели в описании выше такие номера версий, как: `~3.0.0` или `^0.13.0`. Что они означают, и какие еще спецификаторы версий вы можете использовать?

Этот символ указывает, какие обновления принимает ваш пакет, из данной зависимости.

Учитывая, что при использовании semver (semantic versioning) все версии имеют 3 цифры, первая - основной выпуск, вторая - минорный выпуск и третья - выпуск патча, у вас есть следующие правила:

- `~`: если вы пишете `~0.13.0`, вы хотите обновлять только выпуски патчей: `0.13.1` подходит, а `0.14.0` - нет.
- `^`: если вы пишете `^0.13.0`, вы хотите обновлять патч и минорные релизы: `0.13.1`, `0.14.0` и так далее.
- `*`: если вы пишете `*`, это означает, что вы принимаете все обновления, включая основные обновления версий.
- `>`: вы принимаете любую версию выше той, которую вы указали.
- `>=`: вы принимаете любую версию, равную или более высокую, чем та, которую вы указали
- `<=`: вы принимаете любую версию, равную или ниже указанной вами
- `<`: вы принимаете любую версию ниже указанной.

Существуют и другие правила:

- без символа: вы принимаете только ту конкретную версию, которую вы указали
- `latest`: вы хотите использовать последнюю доступную версию

и вы можете объединить большинство из вышеперечисленных правил в диапазоны, например: `1.0.0 || >=1.1.0 <1.2.0`, чтобы использовать либо 1.0.0, либо один релиз, начиная с 1.1.0, но ниже 1.2.0.

### Файл package-lock.json {#the-package-lock-json-file}

Файл package-lock.json автоматически генерируется при установке пакетов node.

В версии 5 npm представил файл `package-lock.json`.

Что это такое? Вы, вероятно, знаете о файле `package.json`, который гораздо более распространен и существует гораздо дольше.

Цель этого файла - отслеживать точную версию каждого установленного пакета, чтобы продукт на 100% воспроизводился одинаково, даже если пакеты обновляются их сопровождающими.

Это решает очень специфическую проблему, которую `package.json` оставил нерешенной. В package.json вы можете указать, до каких версий вы хотите обновиться (patch или minor), используя нотацию **semver**, например:

- если вы пишете `~0.13.0`, вы хотите обновлять только релизы патчей: `0.13.1` подойдет, а `0.14.0` - нет.
- если вы пишете `^0.13.0`, вы хотите обновлять патч и минорные релизы: `0.13.1`, `0.14.0` и так далее.
- если вы пишете `0.13.0`, это точная версия, которая будет использоваться всегда.

Вы не фиксируете в Git свою папку node_modules, которая обычно огромна, и когда вы пытаетесь воспроизвести проект на другой машине с помощью команды `npm install`, если вы указали синтаксис `~` и был выпущен патч-релиз пакета, будет установлен именно он. То же самое для `^` и минорных релизов.

Если вы указываете точные версии, как `0.13.0` в примере, эта проблема вас не коснется.

Это можете быть вы, или другой человек, пытающийся инициализировать проект на другом конце света, запустив `npm install`.

Таким образом, ваш исходный проект и вновь инициализированный проект на самом деле разные. Даже если патч или минорный релиз не должен вносить разрушающих изменений, мы все знаем, что в них могут (и будут) проскальзывать ошибки.

В `package-lock.json` устанавливается текущая версия каждого пакета **в камне**, и `npm` будет использовать именно эти версии при выполнении `npm install`.

Эта концепция не нова, и менеджеры пакетов других языков программирования (например, Composer в PHP) используют подобную систему в течение многих лет.

Файл `package-lock.json` должен быть зафиксирован в вашем Git-репозитории, чтобы его могли получить другие люди, если проект публичный или у вас есть соавторы, или если вы используете Git в качестве источника для развертывания.

Версии зависимостей будут обновлены в файле `package-lock.json`, когда вы запустите `npm update`.

#### Пример

Это пример структуры файла `package-lock.json`, который мы получаем, когда запускаем `npm install cowsay` в пустой папке:

```language-json
{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "ansi-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
      "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg="
    },
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz",
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkMAjufp+0F9eLjzRnOHzVAYeIYFF5po5NjRrgefnRMQ==",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    "get-stdin": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-5.0.1.tgz",
      "integrity": "sha1-Ei4WFZHiH/TFJTAwVpPyDmOTo5g="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8="
    },
    "minimist": {
      "version": "0.0.10",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-0.0.10.tgz",
      "integrity": "sha1-3j+YVD2/lggr5IrRoMfNqDYwHc8="
    },
    "optimist": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.6.1.tgz",
      "integrity": "sha1-2j6nRob6IaGaERwybpDrFaAZZoY=",
      "requires": {
        "minimist": "~0.0.1",
        "wordwrap": "~0.0.2"
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVa",
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      }
    },
    "strip-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
      "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
      "requires": {
        "ansi-regex": "^3.0.0"
      }
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8="
    },
    "wordwrap": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
      "integrity": "sha1-o9XabNXAvAAI03I0u68b7WMFkQc="
    }
  }
}
```

Мы установили `cowsay`, который зависит от:

- `get-stdin`
- `optimist`
- `string-width`
- `strip-eof`

В свою очередь, эти пакеты требуют других пакетов, что видно из свойства `requires`, которым обладают некоторые из них:

- `ansi-regex`
- `is-fullwidth-code-point`
- `minimist`
- `wordwrap`
- `strip-eof`

Они добавляются в файл в алфавитном порядке, и каждый из них имеет поле `version`, поле `resolved`, указывающее на местоположение пакета, и строку `integrity`, которую мы можем использовать для проверки пакета.

### Найти установленную версию пакета npm

Чтобы узнать последнюю версию всех установленных пакетов npm, включая их зависимости:

    npm list

Пример:

    ❯ npm list
    /Users/flavio/dev/node/cowsay
    └─┬ cowsay@1.3.1
      ├── get-stdin@5.0.1
      ├─┬ optimist@0.6.1
      │ ├── minimist@0.0.10
      │ └── wordwrap@0.0.3
      ├─┬ string-width@2.1.1
      │ ├── is-fullwidth-code-point@2.0.0
      │ └─┬ strip-ansi@4.0.0
      │ └── ansi-regex@3.0.0
      └── strip-eof@1.0.0

Вы также можете просто открыть файл `package-lock.json`, но это требует некоторого визуального сканирования.

`npm list -g` - то же самое, но для глобально установленных пакетов.

Чтобы получить только пакеты верхнего уровня (в основном те, которые вы сказали npm установить и перечислили в файле `package.json`), выполните команду `npm list --depth=0`:

    ❯ npm list --depth=0
    /Users/flavio/dev/node/cowsay
    └── cowsay@1.3.1

Вы можете получить версию конкретного пакета, указав его имя:

    ❯ npm list cowsay
    /Users/flavio/dev/node/cowsay
    └── cowsay@1.3.1

Это также работает для зависимостей пакетов, которые вы установили:

    ❯ npm list minimist
    /Users/flavio/dev/node/cowsay
    └─┬ cowsay@1.3.1
      └─┬ optimist@0.6.1
      └── minimist@0.0.10

Если вы хотите посмотреть, какая последняя версия пакета доступна в репозитории npm, выполните команду `npm view [имя_пакета] version`:

    ❯ npm view cowsay version

    1.3.1

### Install an older version of an npm package

Installing an older version of an npm package might be useful to solve a compatibility problem.

You can install an old version of an npm package using the `@` syntax:

    npm install <package>@<version>

Example:

    npm install cowsay

installs version 1.3.1 (at the time of writing).

Install version 1.2.0 with:

    npm install cowsay@1.2.0

The same can be done with global packages:

    npm install -g webpack@4.16.4

You might also be interested in listing all the previous version of a package. You can do it with `npm view <package> ve`rsions:

    ❯ npm view cowsay versions

    [ '1.0.0',
      '1.0.1',
      '1.0.2',
      '1.0.3',
      '1.1.0',
      '1.1.1',
      '1.1.2',
      '1.1.3',
      '1.1.4',
      '1.1.5',
      '1.1.6',
      '1.1.7',
      '1.1.8',
      '1.1.9',
      '1.2.0',
      '1.2.1',
      '1.3.0',
      '1.3.1' ]

### Update all the Node dependencies to their latest version

When you install a package using `npm install <packagena`me\>, the latest available version of the package is downloaded and put i`n the node_m`odules folder, and a corresponding entry is added t`o the packag`e.jso`n and package-loc`k.json files that are present in your current folder.

npm calculates the dependencies and installs the latest available version of those as well.

Let's say you install [`cowsay`](https://www.npmjs.com/package/cowsay){rel="noopener"}, a cool command line tool that lets you make a cow say **things**.

When you `npm install cowsay`, this entry is added to the `package.json` file:

```language-json
{
  "dependencies": {
    "cowsay": "^1.3.1"
  }
}
```

and this is an extract of `package-lock.json`, where I removed the nested dependencies for clarity:

```language-json
{
  "requires": true,
  "lockfileVersion": 1,
  "dependencies": {
    "cowsay": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/cowsay/-/cowsay-1.3.1.tgz",
      "integrity": "sha512-3PVFe6FePVtPj1HTeLin9v8WyLl+VmM1l1H/5P+BTTDkMAjufp+0F9eLjzRnOH",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    }
  }
}
```

Now those 2 files tell us that we installed version `1.3.1` of cowsay, and our rule for updates is `^1.3.1`, which for the npm versioning rules (explained later on) means that npm can update to patch and minor releases: `0.13.1`, `0.14.0` and so on.

If there is a new minor or patch release and we type `npm update`, the installed version is updated, and the `package-lock.json` file diligently filled with the new version.

`package.json` remains unchanged.

To discover new releases of the packages, you run `npm outdated`.

Here's the list of a few outdated packages in one repository I didn't update for quite a while:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/dQXY78UwUHW2iHblpRRLd8YdM4Zvdyf-3ctc"
class="kg-image" loading="lazy" width="800" height="530"
alt="dQXY78UwUHW2iHblpRRLd8YdM4Zvdyf-3ctc" />
</figure>

Some of those updates are major releases. Running `npm update` won't update the version of those. Major releases are never updated in this way because they (by definition) introduce breaking changes, and `npm` want to save you trouble.

To update to a new major version all the packages, install the `npm-check-updates` package globally:

    npm install -g npm-check-updates

then run it:

    ncu -u

This will upgrade all the version hints in the `package.json` file, to `dependencies` and `devDependencies`, so npm can install the new major version.

You are now ready to run the update:

    npm update

If you just downloaded the project without the `node_modules` dependencies and you want to install the shiny new versions first, just run

    npm install

### Semantic Versioning using npm

Semantic Versioning is a convention used to provide a meaning to versions.

If there's one great thing in Node.js packages, is that all agreed on using Semantic Versioning for their version numbering.

The Semantic Versioning concept is simple: all versions have 3 digits: `x.y.z`.

- the first digit is the major version
- the second digit is the minor version
- the third digit is the patch version

When you make a new release, you don't just up a number as you please, but you have rules:

- you up the major version when you make incompatible API changes
- you up the minor version when you add functionality in a backward-compatible manner
- you up the patch version when you make backward-compatible bug fixes

The convention is adopted all across programming languages, and it is very important that every `npm` package adheres to it, because the whole system depends on that.

Why is that so important?

Because `npm` set some rules we can use in the [`package.json` file](https://flaviocopes.com/package-json/) to choose which versions it can update our packages to, when we run `npm update`.

The rules use those symbols:

- `^`
- `~`
- \`\>
- `>=`
- `<`
- `<=`
- `=`
- `-`
- `||`

Let's see those rules in detail:

- `^`: if you write `^0.13.0` when running `npm update` it can update to patch and minor releases: `0.13.1`, `0.14.0` and so on.
- `~`: if you write `~0.13.0`, when running `npm update` it can update to patch releases: `0.13.1` is ok, but `0.14.0` is not.
- `<`: you accept any version higher than the one you specify
- `>=`: you accept any version equal to or higher than the one you specify
- `<=`: you accept any version equal or lower to the one you specify
- `<`: you accept any version lower to the one you specify
- `=`: you accept that exact version
- `-`: you accept a range of versions. Example: `2.1.0 - 2.6.2`
- `||`: you combine sets. Example: `< 2.1 || > 2.6`

You can combine some of those notations, for example use `1.0.0 || >=1.1.0 <1.2.0` to either use 1.0.0 or one release from 1.1.0 up, but lower than 1.2.0.

There are other rules, too:

- no symbol: you accept only that specific version you specify (`1.2.1`)
- `latest`: you want to use the latest version available

### Uninstalling npm packages locally or globally

To uninstall a package you have previously installed **locally** (using `npm install <package-na`me\> i`n the node_m`odules folder), run:

    npm uninstall <package-name>

from the project root folder (the folder that contains the node_modules folder).

This operation will also remove the reference in the [`package.json`](https://flaviocopes.com/package-json/){rel="noopener"} [file](https://flaviocopes.com/package-json/){rel="noopener"}.

If the package was a development dependency, listed in the devDependencies of the `package.json` file, you must use the `-D` / `--save-dev` flag to remove it from the file:

    npm uninstall -D <package-name>

If the package is installed **globally**, you need to add the `-g` / `--global` flag:

    npm uninstall -g <package-name>

Example:

    npm uninstall -g webpack

and you can run this command from anywhere you want on your system because the folder where you currently are does not matter.

### npm global or local packages

When is a package best installed globally? And why?

The main difference between local and global packages is this:

- **local packages** are installed in the directory where you run `npm install <package-name>`, and they are put in the `node_modules` folder under this directory
- **global packages** are all put in a single place in your system (exactly where depends on your setup), regardless of where you run `npm install -g <package-name>`

In your code, they are both required in the same way:

```language-js
require('package-name')
```

So when should you install in one way or another?

In general, all packages should be installed **locally**.

This makes sure you can have dozens of applications in your computer, all running a different version of each package if needed.

Updating a global package would make all your projects use the new release, and as you can imagine this might cause nightmares in terms of maintenance, as some packages might break compatibility with further dependencies, and so on.

All projects have their own local version of a package, even if this might appear like a waste of resources, it's minimal compared to the possible negative consequences.

A package should be installed **globally** when it provides an executable command that you run from the shell (CLI), and it's reused across projects.

You can also install executable commands locally and run them using [npx](https://flaviocopes.com/npx/){rel="noopener"}, but some packages are just better installed globally.

Great examples of popular global packages which you might know are:

- `npm`
- `create-react-app`
- `vue-cli`
- `grunt-cli`
- `mocha`
- `react-native-cli`
- `gatsby-cli`
- `forever`
- `nodemon`

You probably have some packages installed globally already on your system. You can see them by running:

    npm list -g --depth 0

on your command line.

### npm dependencies and devDependencies

When is a package a dependency, and when is it a development dependency?

When you install an npm package using `npm install <package-name>`, you are installing it **as a dependency**.

The package is automatically listed in the package.json file, under the `dependencies` list (as of npm 5: before you had to manually specify `--save`).

When you add the `-D` flag, or `--save-dev`, you are installing it as a development dependency, which adds it to the `devDependencies` list.

**Development dependencies** are intended as development-only packages, that are unneeded in production. For example testing packages, webpack or Babel.

When you go **in production**, if you type `npm install` and the folder contains a `package.json` file, they are installed, as npm assumes this is a development deploy.

You need to set the `--production` flag (`npm install --production`) to avoid installing those development dependencies.

### The npx Node Package Runner

`npx` is a very cool way to run the Node.js codes, and provides many useful features.

In this section, I want to introduce a very powerful command that's been available in **npm** starting version 5.2, released in July 2017: **npx**.

If you don't want to install npm, you can install npx as a [standalone package](https://www.npmjs.com/package/npx){rel="noopener"}.

`npx` lets you run code built with Node.js and published through the npm registry.

#### Easily run local commands

Node.js developers used to publish most of the executable commands as global packages, in order for them to be in the path and executable immediately.

This was a pain because you could not really install different versions of the same command.

Running `npx commandname` automatically finds the correct reference of the command inside the `node_modules` folder of a project, without needing to know the exact path, and without requiring the package to be installed globally and in the user's path.

#### Installation-less command execution

There is another great feature of `npm`, which is allowing to run commands without first installing them.

This is pretty useful, mostly because:

1.  you don't need to install anything
2.  you can run different versions of the same command, using the syntax `@version`

A typical demonstration of using `npx` is through the `cowsay` command. `cowsay` will print a cow saying what you wrote in the command. For example:

`cowsay "Hello"` will print

     _______
    < Hello >
     -------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||

Now, this if you have the `cowsay` command globally installed from npm previously, otherwise you'll get an error when you try to run the command.

`npx` allows you to run that npm command without having it installed locally:

    npx cowsay "Hello"

Now, this is a funny useless command. Other scenarios include:

- running the `vue` CLI tool to create new applications and run them: `npx vue create my-vue-app`
- creating a new React app using `create-react-app`: `npx create-react-app my-react-app`

and many more.

Once downloaded, the downloaded code will be wiped.

#### Run some code using a different Node.js version {#run-some-code-using-a-different-node-js-version}

Use the `@` to specify the version, and combine that with the `node` npm package:

    npx node@6 -v #v6.14.3
    npx node@8 -v #v8.11.3

This helps to avoid tools like `nvm` or the other Node version management tools.

#### Run arbitrary code snippets directly from a URL

`npx` does not limit you to the packages published on the npm registry.

You can run code that sits in a [GitHub](https://flaviocopes.com/github/){rel="noopener"} gist, for example:

    npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32

Of course, you need to be careful when running code that you do not control, as with great power comes great responsibility.

### The Event Loop

The Event Loop is one of the most important aspects to understand about JavaScript. This section explains the inner details of how JavaScript works with a single thread, and how it handles asynchronous functions.

I've programmed for years with JavaScript, yet I've never **fully** understood how things work under the hoods. It's completely fine to not know this concept in detail. But as usual, it's helpful to know how it works, and also you might just be a little curious at this point.

Your JavaScript code runs single threaded. There is just one thing happening at a time.

This is a limitation that's actually very helpful, as it simplifies a lot of how you program without worrying about concurrency issues.

You just need to pay attention to how you write your code and avoid anything that could block the thread, like synchronous network calls or infinite [loops](https://flaviocopes.com/javascript-loops/){rel="noopener"}.

Generally, in most browsers there is an event loop for every browser tab, to make every process isolated and avoid a web page with infinite loops or heavy processing to block your entire browser.

The environment manages multiple concurrent event loops, to handle API calls for example. [Web Workers](https://flaviocopes.com/web-workers/){rel="noopener"} run in their own event loop as well.

You mainly need to be concerned that **your code** will run on a single event loop, and write code with this thing in mind to avoid blocking it.

#### Blocking the event loop

Any JavaScript code that takes too long to return back control to the event loop will block the execution of any JavaScript code in the page --- even block the UI thread --- and the user cannot click around, scroll the page, and so on.

Almost all the I/O primitives in JavaScript are non-blocking. Network requests, Node.js file system operations, and so on. Being blocking is the exception, and this is why JavaScript is based so much on callbacks, and more recently on promises and async/await.

#### The call stack

The call stack is a LIFO queue (Last In, First Out).

The event loop continuously checks the **call stack** to see if there's any function that needs to run.

While doing so, it adds any function call it finds to the call stack and executes each one in order.

You know the error stack trace you might be familiar with, in the debugger or in the browser console?

The browser looks up the function names in the call stack to inform you which function originates the current call:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/SFxrWa7lVtAfUsjnjoMqgCGdG4bK0jDvi-11"
class="kg-image" loading="lazy" width="592" height="615"
alt="SFxrWa7lVtAfUsjnjoMqgCGdG4bK0jDvi-11" />
</figure>

#### A simple event loop explanation

Let's pick an example:

```language-js
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  bar()
  baz()
}

foo()
```

This code prints:

    foo
    bar
    baz

as expected.

When this code runs, first `foo()` is called. Inside `foo()` we first call `bar()`, then we call `baz()`.

At this point the call stack looks like this:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/bFPM-QZwRcB6APbq6sSJpyQMZHWRACvJzAly"
class="kg-image" loading="lazy" width="800" height="835"
alt="bFPM-QZwRcB6APbq6sSJpyQMZHWRACvJzAly" />
</figure>

The event loop on every iteration looks if there's something in the call stack, and executes it:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/T3jPPIkLHGvy0QXBrUz8cb3VM0bVVez-joQ4"
class="kg-image" loading="lazy" width="466" height="769"
alt="T3jPPIkLHGvy0QXBrUz8cb3VM0bVVez-joQ4" />
</figure>

until the call stack is empty.

#### Queuing function execution

The above example looks normal, there's nothing special about it: JavaScript finds things to execute, runs them in order.

Let's see how to defer a function until the stack is clear.

The use case of `setTimeout(() => {}), 0)` is to call a function, but execute it once every other function in the code has executed.

Take this example:

```language-js
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  baz()
}

foo()
```

This code prints, maybe surprisingly:

    foo
    baz
    bar

When this code runs, first `foo()` is called. Inside `foo()` we first call `setTimeout`, passing `bar` as an argument, and we instruct it to run immediately as fast as it can, passing `0` as the timer. Then we call `baz()`.

At this point the call stack looks like this:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/iUnlUVBLW8ozpE2ewbJswyp9tOP5OzPUXn0-"
class="kg-image" loading="lazy" width="800" height="762"
alt="iUnlUVBLW8ozpE2ewbJswyp9tOP5OzPUXn0-" />
</figure>

Here is the execution order for all the functions in our program:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/MsT6C2UAZJaEEm6SmU266PO-V4b-DY0wlMqb"
class="kg-image" loading="lazy" width="466" height="769"
alt="MsT6C2UAZJaEEm6SmU266PO-V4b-DY0wlMqb" />
</figure>

Why is this happening?

#### The Message Queue

When `setTimeout()` is called, the Browser or Node.js starts the timer. Once the timer expires, in this case immediately as we put `0` as the timeout, the callback function is put in the **Message Queue**.

The Message Queue is also where user-initiated events like click and keyboard events or fetch responses are queued before your code has the opportunity to react to them. Or also DOM events like `onLoad`.

The loop gives priority to the call stack. It first processes everything it finds in the call stack, and once there's nothing in there, it goes to pick up things in the message queue.

We don't have to wait for functions like `setTimeout`, fetch or other things to do their own work, because they are provided by the browser, and they live on their own threads. For example, if you set the `setTimeout` timeout to 2 seconds, you don't have to wait 2 seconds - the wait happens elsewhere.

#### ES6 Job Queue

ECMAScript 2015 introduced the concept of the Job Queue, which is used by Promises (also introduced in ES6/ES2015). It's a way to execute the result of an async function as soon as possible, rather than being put at the end of the call stack.

Promises that resolve before the current function ends will be executed right after the current function.

I find nice the analogy of a rollercoaster ride at an amusement park: the message queue puts you back in queue with after all the other people in the queue, while the job queue is the fastpass ticket that lets you take another ride right after you finished the previous one.

Example:

```language-js
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =>
    resolve('should be right after baz, before bar')
  ).then((resolve) => console.log(resolve))
  baz()
}

foo()
```

This prints:

    foo
    baz
    should be right after foo, before bar
    bar

That's a big difference between Promises (and `async/await`, which is built on promises) and plain old asynchronous functions through `setTimeout()` or other platform APIs.

### Understanding process.nextTick() {#understanding-process-nexttick-}

As you try to understand the Node.js event loop, one important part of it is `process.nextTick()`. It interacts with the event loop in a special way.

Every time the event loop takes a full trip, we call it a tick.

When we pass a function to `process.nextTick()`, we instruct the engine to invoke this function at the end of the current operation, before the next event loop tick starts:

```language-js
process.nextTick(() => {
  // do something
})
```

The event loop is busy processing the current function code.

When this operation ends, the JavaScript engine runs all the functions passed to `nextTick` calls during that operation.

It's the way we can tell the JavaScript engine to process a function asynchronously (after the current function), but as soon as possible, not queue it.

Calling `setTimeout(() => {}, 0)` will execute the function in the next tick, much later than when using `nextTick()`.

Use `nextTick()` when you want to make sure that in the next event loop iteration that code is already executed.

### Understanding setImmediate() {#understanding-setimmediate-}

When you want to execute some piece of code asynchronously, but as soon as possible, one option is to use the `setImmediate()` function provided by Node.js:

```language-js
setImmediate(() => {
  // run something
})
```

Any function passed as the `setImmediate()` argument is a callback that's executed in the next iteration of the event loop.

How is `setImmediate()` different from `setTimeout(() => {}, 0)` (passing a 0ms timeout), and from `process.nextTick()`?

A function passed to `process.nextTick()` is going to be executed on the current iteration of the event loop, after the current operation ends. This means it will always execute before `setTimeout()` and `setImmediate()`.

A `setTimeout()` callback with a 0ms delay is very similar to `setImmediate()`. The execution order will depend on various factors, but they will be both run in the next iteration of the event loop.

### Timers

When writing JavaScript code, you might want to delay the execution of a function. Learn how to use `setTimeout()`and `setInterval()` to schedule functions in the future.

#### `setTimeout()` {#settimeout-}

When writing JavaScript code, you might want to delay the execution of a function. This is the job of `setTimeout`.

You can specify a callback function to execute later, and a value expressing how much later you want it to run, in milliseconds:

```language-js
setTimeout(() => {
  // runs after 2 seconds
}, 2000)

setTimeout(() => {
  // runs after 50 milliseconds
}, 50)
```

This syntax defines a new function. You can call whatever other function you want in there, or you can pass an existing function name, and a set of parameters:

```language-js
const myFunction = (firstParam, secondParam) => {
  // do something
}

// runs after 2 seconds
setTimeout(myFunction, 2000, firstParam, secondParam)
```

`setTimeout()` returns the timer id. This is generally not used, but you can store this id, and clear it if you want to delete this scheduled function execution:

```language-js
const id = setTimeout(() => {
  // should run after 2 seconds
}, 2000)

// I changed my mind
clearTimeout(id)
```

#### Zero delay

If you specify the timeout delay to `0`, the callback function will be executed as soon as possible, but after the current function execution:

```language-js
setTimeout(() => {
  console.log('after ')
}, 0)

console.log(' before ')
```

will print `before after`.

This is especially useful to avoid blocking the CPU on intensive tasks and let other functions be executed while performing a heavy calculation, by queuing functions in the scheduler.

Some browsers (IE and Edge) implement a `setImmediate()` method that does this same exact functionality, but it's not standard and [unavailable on other browsers](https://caniuse.com/#feat=setimmediate){rel="noopener"}. But it's a standard function in Node.js.

#### `setInterval()` {#setinterval-}

`setInterval()` is a function similar to `setTimeout()` with a difference. Instead of running the callback function once, it will run it forever, at the specific time interval you specify (in milliseconds):

```language-js
setInterval(() => {
  // runs every 2 seconds
}, 2000)
```

The function above runs every 2 seconds unless you tell it to stop, using `clearInterval`, passing it the interval id that `setInterval` returned:

```language-js
const id = setInterval(() => {
  // runs every 2 seconds
}, 2000)

clearInterval(id)
```

It's common to call `clearInterval` inside the `setInterval` callback function, to let it auto-determine if it should run again or stop. For example this code runs something unless `App.somethingIWait` has the value `arrived`:

```language-js
const interval = setInterval(() => {
  if (App.somethingIWait === 'arrived') {
    clearInterval(interval)
    return
  }
  // otherwise do things
}, 100)
```

#### Recursive setTimeout

`setInterval` starts a function every `n` milliseconds, without any consideration about when a function finished its execution.

If a function takes always the same amount of time, it's all fine:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/eyf875I-cxYqAgNDSeh7CeLg4RXdJIgJphEw"
class="kg-image" loading="lazy" width="800" height="116"
alt="eyf875I-cxYqAgNDSeh7CeLg4RXdJIgJphEw" />
</figure>

Maybe the function takes different execution times, depending on network conditions for example:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/ge2DPdTuZwHnJIyUH9VSLok1J5WHPOlc1DML"
class="kg-image" loading="lazy" width="800" height="114"
alt="ge2DPdTuZwHnJIyUH9VSLok1J5WHPOlc1DML" />
</figure>

And maybe one long execution overlaps the next one:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/I9kJc6l-BIT850OGlNDJre80RcsLp7N4amvy"
class="kg-image" loading="lazy" width="800" height="113"
alt="I9kJc6l-BIT850OGlNDJre80RcsLp7N4amvy" />
</figure>

To avoid this, you can schedule a recursive setTimeout to be called when the callback function finishes:

```language-js
const myFunction = () => {
  // do something
  setTimeout(myFunction, 1000)
}

setTimeout(
  myFunction()
}, 1000)
```

to achieve this scenario:

<figure class="kg-card kg-image-card">
<img
src="https://cdn-media-1.freecodecamp.org/images/B2kod2dFuR5U1uwaaW9SGiC1zX5gIUEaiJ8A"
class="kg-image" loading="lazy" width="800" height="114"
alt="B2kod2dFuR5U1uwaaW9SGiC1zX5gIUEaiJ8A" />
</figure>

`setTimeout` and `setInterval` are also available in Node.js, through the [Timers module](https://nodejs.org/api/timers.html){rel="noopener"}.

Node.js also provides `setImmediate()`, which is equivalent to using `setTimeout(() => {}, 0)`, mostly used to work with the Node.js Event Loop.

### Asynchronous Programming and Callbacks

JavaScript is synchronous by default, and is single threaded. This means that code cannot create new threads and run in parallel.

#### Asynchronicity in Programming Languages

Computers are asynchronous by design.

Asynchronous means that things can happen independently of the main program flow.

In the current consumer computers, every program runs for a specific time slot, and then it stops its execution to let another program continue its execution. This thing runs in a cycle so fast that's impossible to notice, and we think our computers run many programs simultaneously, but this is an illusion (except on multiprocessor machines).

Programs internally use **interrupts**, a signal that's emitted to the processor to gain the attention of the system.

I won't go into the internals of this, but just keep in mind that it's normal for programs to be asynchronous, and halt their execution until they need attention, and the computer can execute other things in the meantime. When a program is waiting for a response from the network, it cannot halt the processor until the request finishes.

Normally, programming languages are synchronous, and some provide a way to manage asynchronicity, in the language or through libraries. C, Java, C#, PHP, Go, Ruby, Swift, Python, they are all synchronous by default. Some of them handle asynchronicity by using threads, spawning a new process.

#### JavaScript

JavaScript is **synchronous** by default and is single threaded. This means that code cannot create new threads and run in parallel.

Lines of code are executed in series, one after another.

For example:

```language-js
const a = 1
const b = 2
const c = a * b
console.log(c)
doSomething()
```

But JavaScript was born inside the browser. Its main job, in the beginning, was to respond to user actions like `onClick`, `onMouseOver`, `onChange`, `onSubmit` and so on. How could it do this with a synchronous programming model?

The answer was in its environment. The **browser** provides a way to do it by providing a set of APIs that can handle this kind of functionality.

More recently, Node.js introduced a non-blocking I/O environment to extend this concept to file access, network calls and so on.

#### Callbacks

You can't know when a user is going to click a button, so what you do is **define an event handler for the click event**.

This event handler accepts a function, which will be called when the event is triggered:

```language-js
document.getElementById('button').addEventListener('click', () => {
  // item clicked
})
```

This is the so-called **callback**.

A callback is a simple function that's passed as a value to another function, and will only be executed when the event happens. We can do this because JavaScript has first-class functions, which can be assigned to variables and passed around to other functions (called **higher-order functions**)

It's common to wrap all your client code in a `load` event listener on the `window` object, which runs the callback function only when the page is ready:

```language-js
window.addEventListener('load', () => {
  // window loaded
  //do what you want
})
```

Callbacks are used everywhere, not just in DOM events.

One common example is by using timers:

```language-js
setTimeout(() => {
  // runs after 2 seconds
}, 2000)
```

[XHR requests](https://en.wikipedia.org/wiki/XMLHttpRequest){rel="noopener"} also accept a callback, in this example by assigning a function to a property that will be called when a particular event occurs (in this case, the state of the request changes):

```language-js
const xhr = new XMLHttpRequest()
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
  xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')
  }
}

xhr.open('GET', 'https://yoursite.com')
xhr.send()
```

#### Handling errors in callbacks

How do you handle errors with callbacks? One very common strategy is to use what Node.js adopted: the first parameter in any callback function is the error object --- error-first callbacks.

If there is no error, the object is `null`. If there is an error, it contains some description of the error and other information.

```language-js
fs.readFile('/file.json', (err, data) => {
  if (err !== null) {
    //handle error
    console.log(err)
    return
  }

  // no errors, process data
  console.log(data)
})
```

#### The problem with callbacks

Callbacks are great for simple cases!

However, every callback adds a level of nesting. When you have lots of callbacks, the code starts to be complicated very quickly:

```language-js
window.addEventListener('load', () => {
  document.getElementById('button').addEventListener('click', () => {
    setTimeout(() => {
      items.forEach(item => {
        // your code here
      })
    }, 2000)
  })
})
```

This is just a simple 4-levels code, but I've seen much more levels of nesting and it's not fun.

How do we solve this?

#### Alternatives to callbacks

Starting with ES6, JavaScript introduced several features that help us with asynchronous code that do not involve using callbacks:

- Promises (ES6)
- Async/Await (ES8)

### Promises

Promises are one way to deal with asynchronous code in JavaScript, without writing too many callbacks in your code.

#### Introduction to promises

A promise is commonly defined as **a proxy for a value that will eventually become available**.

Although being around for years, they have been standardized and introduced in ES2015, and now they have been superseded in ES2017 by async functions.

**Async functions** use the promises API as their building block, so understanding them is fundamental even if in newer code you'll likely use async functions instead of promises.

#### How promises work, in brief

Once a promise has been called, it will start in **pending state**. This means that the caller function continues the execution, while it waits for the promise to do its own processing, and give the caller function some feedback.

At this point, the caller function waits for it to either return the promise in a **resolved state**, or in a **rejected state**, but as you know JavaScript is asynchronous --- so the function continues its execution while the promise does it work.

#### Which JS API use promises?

In addition to your own code and libraries code, promises are used by standard modern Web APIs such as:

- **_the Battery API_**
- the [Fetch API](https://flaviocopes.com/fetch-api/){rel="noopener"}
- [Service Workers](https://flaviocopes.com/service-workers/){rel="noopener"}

It's unlikely that in modern JavaScript you'll find yourself **not** using promises, so let's start diving right into them.

#### Creating a promise

The Promise API exposes a Promise constructor, which you initialize using `new Promise()`:

```language-js
let done = true

const isItDoneYet = new Promise((resolve, reject) => {
  if (done) {
    const workDone = 'Here is the thing I built'
    resolve(workDone)
  } else {
    const why = 'Still working on something else'
    reject(why)
  }
})
```

As you can see the promise checks the `done` global constant, and if that's true, we return a resolved promise, otherwise a rejected promise.

Using `resolve` and `reject` we can communicate back a value, in the above case we just return a string, but it could be an object as well.

#### Consuming a promise

In the last section, we introduced how a promise is created.

Now let's see how the promise can be **consumed** or used:

```language-js
const isItDoneYet = new Promise()
//...

const checkIfItsDone = () => {
  isItDoneYet
    .then((ok) => {
      console.log(ok)
    })
    .catch((err) => {
      console.error(err)
    })
}
```

Running `checkIfItsDone()` will execute the `isItDoneYet()` promise and will wait for it to resolve, using the `then` callback, and if there is an error, it will handle it in the `catch` callback.

#### Chaining promises

A promise can be returned to another promise, creating a chain of promises.

A great example of chaining promises is given by the [Fetch API](https://flaviocopes.com/fetch-api){rel="noopener"}, a layer on top of the `XMLHttpRequest` API, which we can use to get a resource and queue a chain of promises to execute when the resource is fetched.

The Fetch API is a promise-based mechanism, and calling `fetch()` is equivalent to defining our own promise using `new Promise()`.

#### Example of chaining promises

```language-js
const status = (response) => {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response)
  }
  return Promise.reject(new Error(response.statusText))
}

const json = (response) => response.json()

fetch('/todos.json')
  .then(status)
  .then(json)
  .then((data) => {
    console.log('Request succeeded with JSON response', data)
  })
  .catch((error) => {
    console.log('Request failed', error)
  })
```

In this example, we call `fetch()` to get a list of TODO items from the `todos.json` file found in the domain root, and we create a chain of promises.

Running `fetch()` returns a [response](https://fetch.spec.whatwg.org/#concept-response){rel="noopener"}, which has many properties, and within those we reference:

- `status`, a numeric value representing the HTTP status code
- `statusText`, a status message, which is `OK` if the request succeeded

`response` also has a `json()` method, which returns a promise that will resolve with the content of the body processed and transformed into JSON.

So given those premises, this is what happens: the first promise in the chain is a function that we defined, called `status()`, that checks the response status and if it's not a success response (between 200 and 299), it rejects the promise.

This operation will cause the promise chain to skip all the chained promises listed and will skip directly to the `catch()` statement at the bottom, logging the `Request failed` text along with the error message.

If that succeeds instead, it calls the `json()` function we defined. Since the previous promise, when successful, returned the `response` object, we get it as an input to the second promise.

In this case, we return the data JSON processed, so the third promise receives the JSON directly:

```language-js
.then((data) => {
  console.log('Request succeeded with JSON response', data)
})
```

and we simply log it to the console.

#### Handling errors

In the example, in the previous section, we had a `catch` that was appended to the chain of promises.

When anything in the chain of promises fails and raises an error or rejects the promise, the control goes to the nearest `catch()` statement down the chain.

```language-js
new Promise((resolve, reject) => {
  throw new Error('Error')
}).catch((err) => {
  console.error(err)
})

// or

new Promise((resolve, reject) => {
  reject('Error')
}).catch((err) => {
  console.error(err)
})
```

#### Cascading errors

If inside the `catch()` you raise an error, you can append a second `catch()` to handle it, and so on.

```language-js
new Promise((resolve, reject) => {
  throw new Error('Error')
})
  .catch((err) => {
    throw new Error('Error')
  })
  .catch((err) => {
    console.error(err)
  })
```

### Orchestrating promises

#### `Promise.all()` {#promise-all-}

If you need to synchronize different promises, `Promise.all()` helps you define a list of promises, and execute something when they are all resolved.

Example:

```language-js
const f1 = fetch('/something.json')
const f2 = fetch('/something2.json')

Promise.all([f1, f2])
  .then((res) => {
    console.log('Array of results', res)
  })
  .catch((err) => {
    console.error(err)
  })
```

The [ES2015 destructuring assignment](https://flaviocopes.com/ecmascript/#destructuring-assignments){rel="noopener"} syntax allows you to also do:

```language-js
Promise.all([f1, f2]).then(([res1, res2]) => {
  console.log('Results', res1, res2)
})
```

You are not limited to using `fetch` of course, **any promise is good to go**.

#### `Promise.race()` {#promise-race-}

`Promise.race()` runs when the first of the promises you pass to it resolves, and it runs the attached callback just once, with the result of the first promise resolved.

Example:

```language-js
const promiseOne = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, 'one')
})

const promiseTwo = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'two')
})

Promise.race([promiseOne, promiseTwo]).then((result) => {
  console.log(result) // 'two'
})
```

#### Common error, Uncaught TypeError: undefined is not a promise

If you get the `Uncaught TypeError: undefined is not a promise` error in the console, make sure you use `new Promise()` instead of just `Promise()`.

### Async and Await

Discover the modern approach to asynchronous functions in JavaScript.

JavaScript evolved in a very short time from callbacks to promises (ES2015), and since ES2017 asynchronous JavaScript is even simpler with the async/await syntax.

Async functions are a combination of promises and generators, and basically, they are a higher level abstraction over promises. Let me repeat: `async/await` is built on promises.

#### Why were async/await introduced? {#why-were-async-await-introduced}

They reduce the boilerplate around promises, and the "don't break the chain" limitation of chaining promises.

When Promises were introduced in ES2015, they were meant to solve a problem with asynchronous code, and they did, but over the 2 years that separated ES2015 and ES2017, it was clear that promises could not be the final solution.

Promises were introduced to solve the famous callback hell problem, but they introduced complexity on their own, and syntax complexity.

They were good primitives around which a better syntax could be exposed to the developers, so when the time was right we got **async functions**.

They make the code look like it's synchronous, but it's asynchronous and non-blocking behind the scenes.

#### How it works

An `async` function returns a promise, like in this example:

```language-js
const doSomethingAsync = () => {
  return new Promise((resolve) => {
    setTimeout(() => resolve('I did something'), 3000)
  })
}
```

When you want to call this function you prepend `await`, and the calling code will stop **until the promise is resolved or rejected**. One caveat: the client function must be defined as `async`.

Here's an example:

```language-js
const doSomething = async () => {
  console.log(await doSomethingAsync())
}
```

#### A quick example

This is a simple example of `async/await` used to run a function asynchronously:

```language-js
const doSomethingAsync = () => {
  return new Promise((resolve) => {
    setTimeout(() => resolve('I did something'), 3000)
  })
}

const doSomething = async () => {
  console.log(await doSomethingAsync())
}

console.log('Before')
doSomething()
console.log('After')
```

The above code will print the following to the browser console:

    Before
    After
    I did something // after 3s

#### Promise all the things

Prepending the `async` keyword to any function means that the function will return a promise.

Even if it's not doing so explicitly, it will internally make it return a promise.

This is why this code is valid:

    const aFunction = async () => {
      return 'test'
    }

    aFunction().then(alert) // This will alert 'test'

and it's the same as:

```language-js
const aFunction = async () => {
  return Promise.resolve('test')
}

aFunction().then(alert) // This will alert 'test'
```

#### The code is much simpler to read

As you can see in the example above, our code looks very simple. Compare it to code using plain promises, with chaining and callback functions.

And this is a very simple example, the major benefits will arise when the code is much more complex.

For example, here's how you would get a JSON resource and parse it, using promises:

```language-js
const getFirstUserData = () => {
  return fetch('/users.json') // get users list
    .then((response) => response.json()) // parse JSON
    .then((users) => users[0]) // pick first user
    .then((user) => fetch(`/users/${user.name}`)) // get user data
    .then((userResponse) => userResponse.json()) // parse JSON
}

getFirstUserData()
```

And here is the same functionality provided using `await/async`:

```language-js
const getFirstUserData = async () => {
  const response = await fetch('/users.json') // get users list
  const users = await response.json() // parse JSON
  const user = users[0] // pick first user
  const userResponse = await fetch(`/users/${user.name}`) // get user data
  const userData = await userResponse.json() // parse JSON
  return userData
}

getFirstUserData()
```

#### Multiple async functions in series

`async` functions can be chained very easily, and the syntax is much more readable than with plain promises:

```language-js
const promiseToDoSomething = () => {
  return new Promise(resolve => {
    setTimeout(() => resolve('I did something'), 10000)
  })
}

const watchOverSomeoneDoingSomething = async () => {
  const something = await promiseToDoSomething()
  return something + ' and I watched'
}

const watchOverSomeoneWatchingSomeoneDoingSomething = async () => {
  const something = await watchOverSomeoneDoingSomething()
  return something + ' and I watched as well'
}

watchOverSomeoneWatchingSomeoneDoingSomething().then(res => {
  console.log(res)
})
```

Will print:

    I did something and I watched and I watched as well

#### Easier debugging

Debugging promises is hard because the debugger will not step over asynchronous code.

`async/await` makes this very easy because to the compiler it's just like synchronous code.

### The Node.js Event Emitter {#the-node-js-event-emitter}

You can work with custom events in Node.js.

If you worked with JavaScript in the browser, you know how much of the interaction of the user is handled through events: mouse clicks, keyboard button presses, reacting to mouse movements, and so on.

On the back-end side, Node.js offers us the option to build a similar system using the `events` [module](https://nodejs.org/api/events.html){rel="noopener"}.

This module, in particular, offers the `EventEmitter` class, which we'll use to handle our events.

You initialize that using:

```language-js
const EventEmitter = require('events')
const eventEmitter = new EventEmitter()
```

This object exposes, among many others, the `on` and `emit` methods.

- `emit` is used to trigger an event
- `on` is used to add a callback function that's going to be executed when the event is triggered

For example, let's create a `start` event, and as a matter of providing a sample, we react to that by just logging to the console:

```language-js
eventEmitter.on('start', () => {
  console.log('started')
})
```

When we run:

```language-js
eventEmitter.emit('start')
```

The event handler function is triggered, and we get the console log.

**Note:** `addListener()` is an alias for `on()` , in case you see that used.

#### Passing arguments to the event

You can pass arguments to the event handler by passing them as additional arguments to `emit()`:

```language-js
eventEmitter.on('start', (number) => {
  console.log(`started ${number}`)
})

eventEmitter.emit('start', 23)
```

Multiple arguments:

```language-js
eventEmitter.on('start', (start, end) => {
  console.log(`started from ${start} to ${end}`)
})

eventEmitter.emit('start', 1, 100)
```

The EventEmitter object also exposes several other methods to interact with events, like:

- `once()`: add a one-time listener
- `removeListener()` / `off()`: remove an event listener from an event
- `removeAllListeners()`: remove all listeners for an event

### How HTTP requests work

What happens when you type an URL in the browser, from start to finish?

This section describes how browsers perform page requests using the HTTP/1.1 protocol.

If you ever did an interview, you might have been asked: "What happens when you type something into the Google search box and press enter?".

It's one of the most popular questions you get asked. People just want to see if you can explain some rather basic concepts and if you have any clue how the internet actually works.

In this section, I'll analyze what happens when you type an URL in the address bar of your browser and press enter.

It's a very interesting topic to dissect in this handbook, as it touches many technologies I can dive into in separate articles.

This is tech that is very rarely changed, and powers one the most complex and wide ecosystems ever built by humans.

### The HTTP protocol

I analyze URL requests only.

Modern browsers have the capability of knowing if the thing you wrote in the address bar is an actual URL or a search term, and they will use the default search engine if it's not a valid URL.

I assume you type an actual URL.

When you enter the URL and press enter, the browser first builds the full URL.

If you just entered a domain, like `flaviocopes.com`, the browser by default will prepend `HTTP://` to it, defaulting to the HTTP protocol.

#### Things relate to macOS / Linux

Just FYI. Windows might do some things slightly differently.

#### DNS Lookup phase

The browser starts the DNS lookup to get the server IP address.

The domain name is a handy shortcut for us humans, but the internet is organized in such a way that computers can look up the exact location of a server through its IP address, which is a set of numbers like `222.324.3.1` (IPv4).

First, it checks the DNS local cache, to see if the domain has already been resolved recently.

**_Chrome has a handy DNS cache visualizer you can see at this URL: chrome://net-internals/#dns (copy and paste it in the Chrome browser address bar)_**

If nothing is found there, the browser uses the DNS resolver, using the `gethostbyname` POSIX system call to retrieve the host information.

#### gethostbyname

`gethostbyname` first looks in the local hosts file, which on macOS or Linux is located in `/etc/hosts`, to see if the system provides the information locally.

If this does not give any information about the domain, the system makes a request to the DNS server.

The address of the DNS server is stored in the system preferences.

Those are 2 popular DNS servers:

- `8.8.8.8`: the Google public DNS server
- `1.1.1.1`: the CloudFlare DNS server

Most people use the DNS server provided by their internet provider.

The browser performs the DNS request using the UDP protocol.

TCP and UDP are two of the foundational protocols of computer networking. They sit at the same conceptual level, but TCP is connection-oriented, while UDP is a connectionless protocol, more lightweight, used to send messages with little overhead.

How the UDP request is performed is not in the scope of this handbook.

The DNS server might have the domain IP in the cache. It not, it will ask the **root DNS server**. That's a system (composed of 13 actual servers, distributed across the planet) that drives the entire internet.

The DNS server does **not** know the address of each and every domain name on the planet.

What it knows is where the **top-level DNS resolvers** are.

A top-level domain is the domain extension: `.com`, `.it`, `.pizza` and so on.

Once the root DNS server receives the request, it forwards the request to that top-level domain (TLD) DNS server.

Say you are looking for `flaviocopes.com`. The root domain DNS server returns the IP of the .com TLD server.

Now our DNS resolver will cache the IP of that TLD server, so it does not have to ask the root DNS server again for it.

The TLD DNS server will have the IP addresses of the authoritative Name Servers for the domain we are looking for.

How? When you buy a domain, the domain registrar sends the appropriate TDL the name servers. When you update the name servers (for example, when you change the hosting provider), this information will be automatically updated by your domain registrar.

Those are the DNS servers of the hosting provider. They are usually more than 1, to serve as backup.

For example:

- `ns1.dreamhost.com`
- `ns2.dreamhost.com`
- `ns3.dreamhost.com`

The DNS resolver starts with the first, and tries to ask the IP of the domain (with the subdomain, too) you are looking for.

That is the ultimate source of truth for the IP address.

Now that we have the IP address, we can go on in our journey.

#### TCP request handshaking

With the server IP address available, now the browser can initiate a TCP connection to that.

A TCP connection requires a bit of handshaking before it can be fully initialized and you can start sending data.

Once the connection is established, we can send the request

#### Sending the request

The request is a plain text document structured in a precise way determined by the communication protocol.

It's composed of 3 parts:

- the request line
- the request header
- the request body

#### The request line

The request line sets, on a single line:

- the HTTP method
- the resource location
- the protocol version

Example:

    GET / HTTP/1.1

#### The request header

The request header is a set of `field: value` pairs that set certain values.

There are 2 mandatory fields, one of which is `Host`, and the other is `Connection`, while all the other fields are optional:

    Host: flaviocopes.com
    Connection: close

`Host` indicates the domain name which we want to target, while `Connection` is always set to `close` unless the connection must be kept open.

Some of the most used header fields are:

- `Origin`
- `Accept`
- `Accept-Encoding`
- `Cookie`
- `Cache-Control`
- `Dnt`

but many more exist.

The header part is terminated by a blank line.

#### The request body

The request body is optional, not used in GET requests but very much used in POST requests and sometimes in other verbs too, and it can contain data in JSON format.

Since we're now analyzing a GET request, the body is blank and we'll not look more into it.

#### The response

Once the request is sent, the server processes it and sends back a response.

The response starts with the status code and the status message. If the request is successful and returns a 200, it will start with:

    200 OK

The request might return a different status code and message, like one of these:

    404 Not Found
    403 Forbidden
    301 Moved Permanently
    500 Internal Server Error
    304 Not Modified
    401 Unauthorized

The response then contains a list of HTTP headers and the response body (which, since we're making the request in the browser, is going to be HTML).

#### Parse the HTML

The browser now has received the HTML and starts to parse it, and will repeat the exact same process we did not for all the resources required by the page:

- CSS files
- images
- the favicon
- JavaScript files
- ...

How browsers render the page then is out of the scope, but it's important to understand that the process I described is not just for the HTML pages, but for any item that's served over HTTP.

### Build an HTTP Server with Node.js {#build-an-http-server-with-node-js}

Here is the HTTP web server we used as the Node.js Hello World application in the introduction:

```language-js
const http = require('http')

const hostname = 'localhost'
const port = 3000

const server = http.createServer((req, res) => {
  res.statusCode = 200
  res.setHeader('Content-Type', 'text/plain')
  res.end('Hello World\n')
})

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`)
})
```

Let's analyze it briefly. We include the `http` [module](https://nodejs.org/api/http.html){rel="noopener"}.

We use the module to create an HTTP server.

The server is set to listen on the specified port, `3000`. When the server is ready, the `listen`callback function is called.

The callback function we pass is the one that's going to be executed upon every request that comes in. Whenever a new request is received, the `request` [event](https://nodejs.org/api/http.html#http_event_request){rel="noopener"} is called, providing two objects: a request (an [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage){rel="noopener"}object) and a response (an [`http.ServerResponse`](https://nodejs.org/api/http.html#http_class_http_serverresponse){rel="noopener"}object).

`request` provides the request details. Through it, we access the request headers and request data.

`response` is used to populate the data we're going to return to the client.

In this case with:

```language-js
res.statusCode = 200
```

We set the `statusCode` property to `200`, to indicate a successful response.

We also set the `Content-Type` header:

```language-js
res.setHeader('Content-Type', 'text/plain')
```

and we end close the response, adding the content as an argument to `end()`:

```language-js
res.end('Hello World\n')
```

### Making HTTP requests with Node.js {#making-http-requests-with-node-js}

How to perform HTTP requests with Node.js using GET, POST, PUT and DELETE.

I use the term HTTP, but HTTPS is what should be used everywhere, therefore these examples use HTTPS instead of HTTP.

#### Perform a GET Request

```language-js
const https = require('https')
const options = {
  hostname: 'flaviocopes.com',
  port: 443,
  path: '/todos',
  method: 'GET'
}

const req = https.request(options, (res) => {
  console.log(`statusCode: ${res.statusCode}`)
  res.on('data', (d) => {
    process.stdout.write(d)
  })
})

req.on('error', (error) => {
  console.error(error)
})

req.end()
```

#### Perform a POST Request

```language-js
const https = require('https')

const data = JSON.stringify({
  todo: 'Buy the milk',
})

const options = {
  hostname: 'flaviocopes.com',
  port: 443,
  path: '/todos',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': data.length,
  },
}

const req = https.request(options, (res) => {
  console.log(`statusCode: ${res.statusCode}`)
  res.on('data', (d) => {
    process.stdout.write(d)
  })
})

req.on('error', (error) => {
  console.error(error)
})

req.write(data)
req.end()
```

#### PUT and DELETE

PUT and DELETE requests use the same POST request format, and just change the `options.method` value.

### HTTP requests in Node.js using Axios {#http-requests-in-node-js-using-axios}

Axios is a very popular JavaScript library you can use to perform HTTP requests, that works in both Browser and Node.js platforms.

It supports all modern browsers, including support for IE8 and higher.

It is promise-based, and this lets us write async/await code to perform [XHR](https://flaviocopes.com/xhr/){rel="noopener"} requests very easily.

Using Axios has quite a few advantages over the native Fetch API:

- supports older browsers (Fetch needs a polyfill)
- has a way to abort a request
- has a way to set a response timeout
- has built-in CSRF protection
- supports upload progress
- performs automatic JSON data transformation
- works in Node.js

#### Installation

Axios can be installed using npm:

    npm install axios

or yarn:

    yarn add axios

or simply include it in your page using unpkg.com:

```language-js
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

#### The Axios API

You can start an HTTP request from the `axios` object:

```language-js
axios({
  url: 'https://dog.ceo/api/breeds/list/all',
  method: 'get',
  data: {
    foo: 'bar'
  }
})
```

but for convenience, you will generally use:

- `axios.get()`
- `axios.post()`

(like in jQuery you would use `$.get()` and `$.post()` instead of `$.ajax()`)

Axios offers methods for all the HTTP verbs, which are less popular but still used:

- `axios.delete()`
- `axios.put()`
- `axios.patch()`
- `axios.options()`

and a method to get the HTTP headers of a request, discarding the body:

- `axios.head()`

#### GET requests

One convenient way to use Axios is to use the modern (ES2017) `async/await` syntax.

This Node.js example queries the [Dog API](https://dog.ceo/){rel="noopener"} to retrieve a list of all the dog breeds, using `axios.get()`, and it counts them:

```language-js
const axios = require('axios')

const getBreeds = async () => {
  try {
    return await axios.get('https://dog.ceo/api/breeds/list/all')
  } catch (error) {
    console.error(error)
  }
}

const countBreeds = async () => {
  const breeds = await getBreeds()
  if (breeds.data.message) {
    console.log(`Got ${Object.entries(breeds.data.message).length} breeds`)
  }
}

countBreeds()
```

If you don't want to use `async/await` you can use the [Promises](https://flaviocopes.com/javascript-promises/){rel="noopener"} syntax:

```language-js
const axios = require('axios')

const getBreeds = () => {
  try {
    return axios.get('https://dog.ceo/api/breeds/list/all')
  } catch (error) {
    console.error(error)
  }
}

const countBreeds = async () => {
  const breeds = getBreeds()
    .then((response) => {
      if (response.data.message) {
        console.log(
          `Got ${Object.entries(response.data.message).length} breeds`
        )
      }
    })
    .catch((error) => {
      console.log(error)
    })
}

countBreeds()
```

#### Add parameters to GET requests

A GET response can contain parameters in the URL, like this: [`https://site.com/?foo=bar`](https://site.com/?foo=bar.){rel="noopener"}

With Axios you can perform this by simply using that URL:

```language-js
axios.get('https://site.com/?foo=bar')
```

or you can use a `params` property in the options:

```language-js
axios.get('https://site.com/', {
  params: {
    foo: 'bar'
  }
})
```

#### POST Requests

Performing a POST request is just like doing a GET request, but instead of `axios.get`, you use `axios.post`:

    axios.post('https://site.com/')

An object containing the POST parameters is the second argument:

```language-js
axios.post('https://site.com/', {
  foo: 'bar'
})
```

### Using WebSockets in Node.js {#using-websockets-in-node-js}

WebSockets are an alternative to HTTP communication in Web Applications.

They offer a long lived, bidirectional communication channel between client and server.

Once established, the channel is kept open, offering a very fast connection with low latency and overhead.

### Browser support for WebSockets

WebSockets are supported by all modern browsers.

### How WebSockets differ from HTTP

HTTP is a very different protocol, and has a different way of communicating.

HTTP is a request/response protocol: the server returns some data when the client requests it.

With WebSockets:

- the **server can send a message to the client** without the client explicitly requesting something
- the client and the server can **talk to each other simultaneously**
- very little data overhead needs to be exchanged to send messages. This means a **low latency communication**.

WebSockets are great for real-time and long-lived communications.

HTTP is great for occasional data exchange and interactions initiated by the client.

HTTP is much simpler to implement, while WebSockets require a bit more overhead.

### Secured WebSockets

Always use the secure, encrypted protocol for WebSockets, `wss://`.

`ws://` refers to the unsafe WebSockets version (the `http://` of WebSockets), and should be avoided for obvious reasons.

### Create a new WebSockets connection

```language-js
const url = 'wss://myserver.com/something'
const connection = new WebSocket(url)
```

`connection` is a [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket){rel="noopener"} object.

When the connection is successfully established, the `open`event is fired.

Listen for it by assigning a callback function to the `onopen`property of the `connection` object:

```language-js
connection.onopen = () => {
  // ...
}
```

If there's any error, the `onerror` function callback is fired:

```language-js
connection.onerror = error => {
  console.log(`WebSocket error: ${error}`)
}
```

### Sending data to the server using WebSockets

Once the connection is open, you can send data to the server.

You can do so conveniently inside the `onopen` callback function:

```language-js
connection.onopen = () => {
  connection.send('hey')
}
```

### Receiving data from the server using WebSockets

Listen with a callback function on `onmessage`, which is called when the `message` event is received:

```language-js
connection.onmessage = e => {
  console.log(e.data)
}
```

### Implement a WebSockets server in Node.js {#implement-a-websockets-server-in-node-js}

[ws](https://github.com/websockets/ws){rel="noopener"} is a popular WebSockets library for Node.js.

We'll use it to build a WebSockets server. It can also be used to implement a client, and use WebSockets to communicate between two backend services.

Easily install it using:

    yarn init
    yarn add ws

The code you need to write is very little:

```language-js
const WebSocket = require('ws')

const wss = new WebSocket.Server({ port: 8080 })

wss.on('connection', (ws) => {
  ws.on('message', (message) => {
    console.log(`Received message => ${message}`)
  })
  ws.send('ho!')
})
```

This code creates a new server on port 8080 (the default port for WebSockets), and adds a callback function when a connection is established, sending `ho!` to the client, and logging the messages it receives.

### See a live example on Glitch

[Here](https://glitch.com/edit/#!/flavio-websockets-server-example){rel="noopener"} is a live example of a WebSockets server.

[Here](https://glitch.com/edit/#!/flavio-websockets-client-example){rel="noopener"} is a WebSockets client that interacts with the server.

### Working with file descriptors in Node.js {#working-with-file-descriptors-in-node-js}

Before you're able to interact with a file that sits in your file system, you must get a file descriptor.

A file descriptor is what's returned by opening the file using the `open()` method offered by the `fs` module:

```language-js
const fs = require('fs')

fs.open('/Users/flavio/test.txt', 'r', (err, fd) => {
  //fd is our file descriptor
})
```

Notice the `r` we used as the second parameter to the `fs.open()` call.

That flag means we open the file for reading.

Other flags you'll commonly use are

- `r+` open the file for reading and writing
- `w+` open the file for reading and writing, positioning the stream at the beginning of the file. The file is created if not existing
- `a` open the file for writing, positioning the stream at the end of the file. The file is created if not existing
- `a+` open the file for reading and writing, positioning the stream at the end of the file. The file is created if not existing

You can also open the file by using the `fs.openSync` method, which instead of providing the file descriptor object in a callback, it returns it:

```language-js
const fs = require('fs')

try {
  const fd = fs.openSync('/Users/flavio/test.txt', 'r')
} catch (err) {
  console.error(err)
}
```

Once you get the file descriptor, in whatever way you choose, you can perform all the operations that require it, like calling `fs.open()` and many other operations that interact with the file system.

### Node.js file stats {#node-js-file-stats}

Every file comes with a set of details that we can inspect using Node.js.

In particular, using the `stat()` method provided by the `fs` module.

You call it passing a file path, and once Node.js gets the file details it will call the callback function you pass with 2 parameters: an error message, and the file stats:

```language-js
const fs = require('fs')
fs.stat('/Users/flavio/test.txt', (err, stats) => {
  if (err) {
    console.error(err)
    return
  }
  // we have access to the file stats in `stats`
})
```

Node.js provides also a sync method, which blocks the thread until the file stats are ready:

```language-js
const fs = require('fs')
try {
  const stats = fs.stat('/Users/flavio/test.txt')
} catch (err) {
  console.error(err)
}
```

The file information is included in the stats variable. What kind of information can we extract using the stats?

A lot, including:

- if the file is a directory or a file, using `stats.isFile()` and `stats.isDirectory()`
- if the file is a symbolic link using `stats.isSymbolicLink()`
- the file size in bytes using `stats.size`.

There are other advanced methods, but the bulk of what you'll use in your day-to-day programming is this:

```language-js
const fs = require('fs')
fs.stat('/Users/flavio/test.txt', (err, stats) => {
  if (err) {
    console.error(err)
    return
  }

  stats.isFile() // true
  stats.isDirectory() // false
  stats.isSymbolicLink() // false
  stats.size // 1024000 //= 1MB
})
```

### Node.js File Paths {#node-js-file-paths}

Every file in the system has a path.

On Linux and macOS, a path might look like:

`/users/flavio/file.txt`

While Windows computers are different, and have a structure such as:

`C:\users\flavio\file.txt`

You need to pay attention when using paths in your applications, as this difference must be taken into account.

You include this module in your files using:

```language-js
const path = require('path')
```

and you can start using its methods.

#### Getting information out of a path

Given a path, you can extract information out of it using those methods:

- `dirname`: get the parent folder of a file
- `basename`: get the filename part
- `extname`: get the file extension

Example:

```language-js
const notes = '/users/flavio/notes.txt'

path.dirname(notes) // /users/flavio
path.basename(notes) // notes.txt
path.extname(notes) // .txt
```

You can get the file name without the extension by specifying a second argument to `basename`:

```language-js
path.basename(notes, path.extname(notes)) // notes
```

#### Working with paths

You can join two or more parts of a path by using `path.join()`:

```language-js
const name = 'flavio'
path.join('/', 'users', name, 'notes.txt') // '/users/flavio/notes.txt'
```

You can get the absolute path calculation of a relative path using `path.resolve()`:

```language-js
path.resolve('flavio.txt') // '/Users/flavio/flavio.txt' if run from my home folder
```

In this case Node.js will simply append `/flavio.txt` to the current working directory. If you specify a second parameter folder, `resolve` will use the first as a base for the second:

```language-js
path.resolve('tmp', 'flavio.txt') // '/Users/flavio/tmp/flavio.txt' if run from my home folder
```

If the first parameter starts with a slash, that means it's an absolute path:

```language-js
path.resolve('/etc', 'flavio.txt') // '/etc/flavio.txt'
```

`path.normalize()` is another useful function, that will try and calculate the actual path, when it contains relative specifiers like `.` or `..`, or double slashes:

```language-js
path.normalize('/users/flavio/..//test.txt') //  /users/test.txt
```

But `resolve` and `normalize` will **not** check if the path exists. They just calculate a path based on the information they got.

### Reading files with Node.js {#reading-files-with-node-js}

The simplest way to read a file in Node.js is to use the `fs.readFile()` method, passing it the file path and a callback function that will be called with the file data (and the error):

```language-js
const fs = require('fs')

fs.readFile('/Users/flavio/test.txt', (err, data) => {
  if (err) {
    console.error(err)
    return
  }
  console.log(data)
})
```

Alternatively, you can use the synchronous version `fs.readFileSync()`:

```language-js
const fs = require('fs')

try {
  const data = fs.readFileSync('/Users/flavio/test.txt', 'utf8')
  console.log(data)
} catch (err) {
  console.error(err)
}
```

The default encoding is `utf8`, but you can specify a custom encoding using a a second parameter.

Both `fs.readFile()` and `fs.readFileSync()` read the full content of the file in memory before returning the data.

This means that big files are going to have a major impact on your memory consumption and speed of execution of the program.

In this case, a better option is to read the file content using streams.

### Writing files with Node.js {#writing-files-with-node-js}

The easiest way to write to files in Node.js is to use the `fs.writeFile()` API.

Example:

```language-js
const fs = require('fs')

const content = 'Some content!'

fs.writeFile('/Users/flavio/test.txt', content, (err) => {
  if (err) {
    console.error(err)
    return
  }
  // file written successfully
})
```

Alternatively, you can use the synchronous version `fs.writeFileSync()`:

```language-js
const fs = require('fs')

const content = 'Some content!'

try {
  const data = fs.writeFileSync('/Users/flavio/test.txt', content)
  // file written successfully
} catch (err) {
  console.error(err)
}
```

By default, this API will **replace the contents of the file** if it does already exist.

You can modify the default by specifying a flag:

```language-js
fs.writeFile('/Users/flavio/test.txt', content, { flag: 'a+' }, (err) => {})
```

The flags you'll likely use are:

- `r+` open the file for reading and writing
- `w+` open the file for reading and writing, positioning the stream at the beginning of the file. The file is created if not existing
- `a` open the file for writing, positioning the stream at the end of the file. The file is created if not existing
- `a+` open the file for reading and writing, positioning the stream at the end of the file. The file is created if not existing

You can find more about [flags](https://nodejs.org/api/fs.html#fs_file_system_flags){rel="noopener"}.

#### Append to a file

A handy method to append content to the end of a file is `fs.appendFile()` (and its `fs.appendFileSync()` counterpart):

```language-js
const content = 'Some content!'

fs.appendFile('file.log', content, (err) => {
  if (err) {
    console.error(err)
    return
  }
  // done!
})
```

#### Using streams

All those methods write the full content to the file before returning the control back to your program (in the async version, this means executing the callback)

In this case, a better option is to write the file content using streams.

### Working with folders in Node.js {#working-with-folders-in-node-js}

The Node.js `fs` core module provides many handy methods you can use to work with folders.

#### Check if a folder exists

Use `fs.access()` to check if the folder exists and Node.js can access it with its permissions.

#### Create a new folder

Use `fs.mkdir()` or `fs.mkdirSync()` to create a new folder:

```language-js
const fs = require('fs')

const folderName = '/Users/flavio/test'

try {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir)
  }
} catch (err) {
  console.error(err)
}
```

#### Read the content of a directory

Use `fs.readdir()` or `fs.readdirSync` to read the contents of a directory.

This piece of code reads the content of a folder, both files and subfolders, and returns their relative path:

```language-js
const fs = require('fs')
const path = require('path')

const folderPath = '/Users/flavio'

fs.readdirSync(folderPath)
```

You can get the full path:

```language-js
fs.readdirSync(folderPath).map(fileName => {
  return path.join(folderPath, fileName)
}
```

You can also filter the results to only return the files, and exclude the folders:

```language-js
const isFile = fileName => {
  return fs.lstatSync(fileName).isFile()
}

fs.readdirSync(folderPath).map(fileName => {
  return path.join(folderPath, fileName)
}).filter(isFile)
```

#### Rename a folder

Use `fs.rename()` or `fs.renameSync()` to rename folder.

The first parameter is the current path, the second the new path:

```language-js
const fs = require('fs')

fs.rename('/Users/flavio', '/Users/roger', err => {
  if (err) {
    console.error(err)
    return
  }
  // done
})
```

`fs.renameSync()` is the synchronous version:

```language-js
const fs = require('fs')

try {
  fs.renameSync('/Users/flavio', '/Users/roger')
} catch (err) {
  console.error(err)
}
```

#### Remove a folder

Use `fs.rmdir()` or `fs.rmdirSync()` to remove a folder.

Removing a folder that has content can be more complicated than you need.

In this case I recommend installing the `fs-extra` module, which is very popular and well maintained, and it's a drop-in replacement of the `fs` module, providing more features on top of it.

In this case the `remove()` method is what you want.

Install it using:

`npm install fs-extra`

and use it like this:

```language-js
const fs = require('fs-extra')

const folder = '/Users/flavio'

fs.remove(folder, err => {
  console.error(err)
})
```

It can also be used with promises:

```language-js
fs.remove(folder).then(() => {
  // done
}).catch(err => {
  console.error(err)
})
```

or with `async/await`:

```language-js
async function removeFolder(folder) {
  try {
    await fs.remove(folder)
    // done
  } catch (err) {
    console.error(err)
  }
}

const folder = '/Users/flavio'
removeFolder(folder)
```

### The Node.js fs module {#the-node-js-fs-module}

The `fs` module provides a lot of very useful functionality to access and interact with the file system.

There is no need to install it. Being part of the Node.js core, it can be used by simply requiring it:

```language-js
const fs = require('fs')
```

Once you do so, you have access to all its methods, which include:

- `fs.access()`: check if the file exists and Node can access it with its permissions
- `fs.appendFile()`: append data to a file. If the file does not exist, it's created
- `fs.chmod()`: change the permissions of a file specified by the filename passed. Related: `fs.lchmod()`, `fs.fchmod()`
- `fs.chown()`: change the owner and group of a file specified by the filename passed. Related: `fs.fchown()`, `fs.lchown()`
- `fs.close()`: close a file descriptor
- `fs.copyFile()`: copies a file
- `fs.createReadStream()`: create a readable file stream
- `fs.createWriteStream()`: create a writable file stream
- `fs.link()`: create a new hard link to a file
- `fs.mkdir()`: create a new folder
- `fs.mkdtemp()`: create a temporary directory
- `fs.open()`: set the file mode
- `fs.readdir()`: read the contents of a directory
- `fs.readFile()`: read the content of a file. Related: `fs.read()`
- `fs.readlink()`: read the value of a symbolic link
- `fs.realpath()`: resolve relative file path pointers (`.`, `..`) to the full path
- `fs.rename()`: rename a file or folder
- `fs.rmdir()`: remove a folder
- `fs.stat()`: returns the status of the file identified by the filename passed. Related: `fs.fstat()`, `fs.lstat()`
- `fs.symlink()`: create a new symbolic link to a file
- `fs.truncate()`: truncate to the specified length the file identified by the filename passed. Related: `fs.ftruncate()`
- `fs.unlink()`: remove a file or a symbolic link
- `fs.unwatchFile()`: stop watching for changes on a file
- `fs.utimes()`: change the timestamp of the file identified by the filename passed. Related: `fs.futimes()`
- `fs.watchFile()`: start watching for changes on a file. Related: `fs.watch()`
- `fs.writeFile()`: write data to a file. Related: `fs.write()`

One peculiar thing about the `fs` module is that all the methods are asynchronous by default, but they can also work synchronously by appending `Sync`.

For example:

- `fs.rename()`
- `fs.renameSync()`
- `fs.write()`
- `fs.writeSync()`

This makes a huge difference in your application flow.

**Note:** Node 10 includes [experimental support](https://nodejs.org/api/fs.html#fs_fs_promises_api){rel="noopener"} for a promise based API.

For example let's examine the `fs.rename()` method. The asynchronous API is used with a callback:

```language-js
const fs = require('fs')

fs.rename('before.json', 'after.json', (err) => {
  if (err) {
    return console.error(err)
  }
  // done
})
```

A synchronous API can be used like this, with a `try/catch` block to handle errors:

```language-js
const fs = require('fs')

try {
  fs.renameSync('before.json', 'after.json')
  // done
} catch (err) {
  console.error(err)
}
```

The key difference here is that the execution of your script will block in the second example, until the file operation succeeded.

### The Node.js path module {#the-node-js-path-module}

The `path` module provides a lot of very useful functionality to access and interact with the file system.

There is no need to install it. Being part of the Node.js core, it can be used by simply requiring it:

```language-js
const path = require('path')
```

This module provides `path.sep` which provides the path segment separator (`\` on Windows, and `/` on Linux / macOS), and `path.delimiter` which provides the path delimiter (`;` on Windows, and `:` on Linux / macOS).

These are the `path` methods.

#### `path.basename()` {#path-basename-}

Return the last portion of a path. A second parameter can filter out the file extension:

```language-js
require('path').basename('/test/something') // something
require('path').basename('/test/something.txt') // something.txt
require('path').basename('/test/something.txt', '.txt') // something
```

#### `path.dirname()` {#path-dirname-}

Return the directory part of a path:

```language-js
require('path').dirname('/test/something') // /test
require('path').dirname('/test/something/file.txt') // /test/something
```

#### `path.extname()` {#path-extname-}

Return the extension part of a path:

```language-js
require('path').dirname('/test/something') // ''
require('path').dirname('/test/something/file.txt') // '.txt'
```

#### `path.isAbsolute()` {#path-isabsolute-}

Returns true if it's an absolute path:

```language-js
require('path').isAbsolute('/test/something') // true
require('path').isAbsolute('./test/something') // false
```

#### `path.join()` {#path-join-}

Joins two or more parts of a path:

```language-js
const name = 'flavio'
require('path').join('/', 'users', name, 'notes.txt') // '/users/flavio/notes.txt'
```

#### `path.normalize()` {#path-normalize-}

Tries to calculate the actual path when it contains relative specifiers like `.` or `..`, or double slashes:

```language-js
require('path').normalize('/users/flavio/..//test.txt') // /users/test.txt
```

#### `path.parse()` {#path-parse-}

Parses a path to an object with the segments that compose it:

- `root`: the root
- `dir`: the folder path starting from the root
- `base`: the file name + extension
- `name`: the file name
- `ext`: the file extension

Example:

```language-js
require('path').parse('/users/test.txt')
```

results in:

```language-js
{
  root: '/',
  dir: '/users',
  base: 'test.txt',
  ext: '.txt',
  name: 'test'
}
```

#### `path.relative()` {#path-relative-}

Accepts 2 paths as arguments. Returns the the relative path from the first path to the second, based on the current working directory.

Example:

```language-js
require('path').relative('/Users/flavio', '/Users/flavio/test.txt') // 'test.txt'
require('path').relative('/Users/flavio', '/Users/flavio/something/test.txt') // 'something/test.txt'
```

#### `path.resolve()` {#path-resolve-}

You can get the absolute path calculation of a relative path using `path.resolve()`:

```language-js
path.resolve('flavio.txt') // '/Users/flavio/flavio.txt' if run from my home folder
```

By specifying a second parameter, `resolve` will use the first as a base for the second:

```language-js
path.resolve('tmp', 'flavio.txt') // '/Users/flavio/tmp/flavio.txt' if run from my home folder
```

If the first parameter starts with a slash, that means it's an absolute path:

```language-js
path.resolve('/etc', 'flavio.txt') // '/etc/flavio.txt'
```

### The Node.js os module {#the-node-js-os-module}

This module provides many functions that you can use to retrieve information from the underlying **operating system** and the computer the program runs on, and interact with it.

```language-js
const os = require('os')
```

There are a few useful properties that tell us some key things related to handling files:

`os.EOL` gives the line delimiter sequence. It\'s `\n` on Linux and macOS, and `\r\n` on Windows.

When I say Linux and macOS I mean POSIX platforms. For simplicity I exclude other less popular operating systems Node can run on.

`os.constants.signals` tells us all the constants related to handling process signals, like SIGHUP, SIGKILL and so on.

`os.constants.errno` sets the constants for error reporting, like EADDRINUSE, EOVERFLOW and more.

You can read them all [here](https://nodejs.org/api/os.html#os_signal_constants){rel="noopener"}.

Let's now see the main methods that `os` provides:

- `os.arch()`
- `os.cpus()`
- `os.endianness()`
- `os.freemem()`
- `os.homedir()`
- `os.hostname()`
- `os.loadavg()`
- `os.networkInterfaces()`
- `os.platform()`
- `os.release()`
- `os.tmpdir()`
- `os.totalmem()`
- `os.type()`
- `os.uptime()`
- `os.userInfo()`

#### `os.arch()` {#os-arch-}

Return the string that identifies the underlying architecture, like `arm`, `x64`, `arm64`.

#### `os.cpus()` {#os-cpus-}

Return information on the CPUs available on your system.

Example:

```language-js
[
  {
    model: 'Intel(R) Core(TM)2 Duo CPU P8600 @ 2.40GHz',
    speed: 2400,
    times: {
      user: 281685380,
      nice: 0,
      sys: 187986530,
      idle: 685833750,
      irq: 0,
    },
  },
  {
    model: 'Intel(R) Core(TM)2 Duo CPU P8600 @ 2.40GHz',
    speed: 2400,
    times: {
      user: 282348700,
      nice: 0,
      sys: 161800480,
      idle: 703509470,
      irq: 0,
    },
  },
]
```

#### `os.endianness()` {#os-endianness-}

Return `BE` or `LE` depending if Node.js was compiled with [Big Endian or Little Endian](https://en.wikipedia.org/wiki/Endianness){rel="noopener"}.

#### `os.freemem()` {#os-freemem-}

Return the number of bytes that represent the free memory in the system.

#### `os.homedir()` {#os-homedir-}

Return the path to the home directory of the current user.

Example:

```language-js
'/Users/flavio'
```

#### `os.hostname()` {#os-hostname-}

Return the hostname.

#### `os.loadavg()` {#os-loadavg-}

Return the calculation made by the operating system on the load average.

It only returns a meaningful value on Linux and macOS.

Example:

```language-js
[ 3.68798828125, 4.00244140625, 11.1181640625 ]
```

#### `os.networkInterfaces()` {#os-networkinterfaces-}

Returns the details of the network interfaces available on your system.

Example:

```language-js
{
  lo0: [
    {
      address: '127.0.0.1',
      netmask: '255.0.0.0',
      family: 'IPv4',
      mac: 'fe:82:00:00:00:00',
      internal: true,
    },
    {
      address: '::1',
      netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
      family: 'IPv6',
      mac: 'fe:82:00:00:00:00',
      scopeid: 0,
      internal: true,
    },
    {
      address: 'fe80::1',
      netmask: 'ffff:ffff:ffff:ffff::',
      family: 'IPv6',
      mac: 'fe:82:00:00:00:00',
      scopeid: 1,
      internal: true,
    },
  ],
  en1: [
    {
      address: 'fe82::9b:8282:d7e6:496e',
      netmask: 'ffff:ffff:ffff:ffff::',
      family: 'IPv6',
      mac: '06:00:00:02:0e:00',
      scopeid: 5,
      internal: false,
    },
    {
      address: '192.168.1.38',
      netmask: '255.255.255.0',
      family: 'IPv4',
      mac: '06:00:00:02:0e:00',
      internal: false,
    },
  ],
  utun0: [
    {
      address: 'fe80::2513:72bc:f405:61d0',
      netmask: 'ffff:ffff:ffff:ffff::',
      family: 'IPv6',
      mac: 'fe:80:00:20:00:00',
      scopeid: 8,
      internal: false,
    },
  ]
}
```

#### `os.platform()` {#os-platform-}

Return the platform that Node.js was compiled for:

- `darwin`
- `freebsd`
- `linux`
- `openbsd`
- `win32`
- ...more

#### `os.release()` {#os-release-}

Returns a string that identifies the operating system release number.

#### `os.tmpdir()` {#os-tmpdir-}

Returns the path to the assigned temp folder.

#### `os.totalmem()` {#os-totalmem-}

Returns the number of bytes that represent the total memory available in the system.

#### `os.type()` {#os-type-}

Identifies the operating system:

- `Linux`
- `Darwin` on macOS
- `Windows_NT` on Windows

#### `os.uptime()` {#os-uptime-}

Returns the number of seconds the computer has been running since it was last rebooted.

### The Node.js events module {#the-node-js-events-module}

The `events` module provides us the `EventEmitter` class, which is key to working with events in Node.js.

I published a full [article](https://flaviocopes.com/node-event-emitter/){rel="noopener"} on that, so here I will just describe the API without further examples on how to use it.

```language-js
const EventEmitter = require('events')
const door = new EventEmitter()
```

The event listener eats its own dog food and uses these events:

- `newListener` when a listener is added
- `removeListener` when a listener is removed

Here's a detailed description of the most useful methods:

- `emitter.addListener()`
- `emitter.emit()`
- `emitter.eventNames()`
- `emitter.getMaxListeners()`
- `emitter.listenerCount()`
- `emitter.listeners()`
- `emitter.off()`
- `emitter.on()`
- `emitter.once()`
- `emitter.prependListener()`
- `emitter.prependOnceListener()`
- `emitter.removeAllListeners()`
- `emitter.removeListener()`
- `emitter.setMaxListeners()`

#### `emitter.addListener()` {#emitter-addlistener-}

Alias for `emitter.on()`.

#### `emitter.emit()` {#emitter-emit-}

Emits an event. It synchronously calls every event listener in the order they were registered.

#### `emitter.eventNames()` {#emitter-eventnames-}

Return an array of strings that represent the events registered on the current EventListener:

```language-js
door.eventNames()
```

#### `emitter.getMaxListeners()` {#emitter-getmaxlisteners-}

Get the maximum amount of listeners one can add to an EventListener object, which defaults to 10 but can be increased or lowered by using `setMaxListeners()`:

```language-js
door.getMaxListeners()
```

#### `emitter.listenerCount()` {#emitter-listenercount-}

Get the count of listeners of the event passed as parameter:

```language-js
door.listenerCount('open')
```

#### `emitter.listeners()` {#emitter-listeners-}

Gets an array of listeners of the event passed as parameter:

```language-js
door.listeners('open')
```

#### `emitter.off()` {#emitter-off-}

Alias for `emitter.removeListener()` added in Node 10.

#### `emitter.on()` {#emitter-on-}

Adds a callback function that's called when an event is emitted.

Usage:

```language-js
door.on('open', () => {
  console.log('Door was opened')
})
```

#### `emitter.once()` {#emitter-once-}

Adds a callback function that's called when an event is emitted for the first time after registering this. This callback is only going to be called once, never again.

```language-js
const EventEmitter = require('events')
const ee = new EventEmitter()

ee.once('my-event', () => {
  // call callback function once
})
```

#### `emitter.prependListener()` {#emitter-prependlistener-}

When you add a listener using `on` or `addListener`, it\'s added last in the queue of listeners, and called last. Using `prependListener` it\'s added, and called, before other listeners.

#### `emitter.prependOnceListener()` {#emitter-prependoncelistener-}

When you add a listener using `once`, it\'s added last in the queue of listeners, and called last. Using `prependOnceListener` it\'s added, and called, before other listeners.

#### `emitter.removeAllListeners()` {#emitter-removealllisteners-}

Removes all listeners of an event emitter object listening to a specific event:

```language-js
door.removeAllListeners('open')
```

#### `emitter.removeListener()` {#emitter-removelistener-}

Remove a specific listener. You can do this by saving the callback function to a variable, when added, so you can reference it later:

```language-js
const doSomething = () => {}
door.on('open', doSomething)
door.removeListener('open', doSomething)
```

#### `emitter.setMaxListeners()` {#emitter-setmaxlisteners-}

Sets the maximum amount of listeners one can add to an EventListener object, which defaults to 10 but can be increased or lowered:

```language-js
door.setMaxListeners(50)
```

### The Node.js http module {#the-node-js-http-module}

The `http` module of Node.js provides useful functions and classes to build an HTTP server. It is a key module to Node.js networking.

It can be included using:

```language-js
const http = require('http')
```

The module provides some properties and methods, and some classes.

#### Properties

#### `http.METHODS` {#http-methods}

This property lists all the HTTP methods supported:

    > require('http').METHODS

    /* [
      'ACL',
      'BIND',
      'CHECKOUT',
      'CONNECT',
      'COPY',
      'DELETE',
      'GET',
      'HEAD',
      'LINK',
      'LOCK',
      'M-SEARCH',
      'MERGE',
      'MKACTIVITY',
      'MKCALENDAR',
      'MKCOL',
      'MOVE',
      'NOTIFY',
      'OPTIONS',
      'PATCH',
      'POST',
      'PROPFIND',
      'PROPPATCH',
      'PURGE',
      'PUT',
      'REBIND',
      'REPORT',
      'SEARCH',
      'SUBSCRIBE',
      'TRACE',
      'UNBIND',
      'UNLINK',
      'UNLOCK',
      'UNSUBSCRIBE'
    ] */

#### `http.STATUS_CODES` {#http-status_codes}

This property lists all the HTTP status codes and their description:

```language-js
> require('http').STATUS_CODES

/* {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',
  208: 'Already Reported',
  226: 'IM Used',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: "I'm a teapot",
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',
  423: 'Locked',
  424: 'Failed Dependency',
  425: 'Unordered Collection',
  426: 'Upgrade Required',
  428: 'Precondition Required',
  429: 'Too Many Requests',
  431: 'Request Header Fields Too Large',
  451: 'Unavailable For Legal Reasons',
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage',
  508: 'Loop Detected',
  509: 'Bandwidth Limit Exceeded',
  510: 'Not Extended',
  511: 'Network Authentication Required',
} */
```

#### `http.globalAgent` {#http-globalagent}

Points to the global instance of the Agent object, which is an instance of the `http.Agent`class.

It's used to manage connections persistence and reuse for HTTP clients, and it's a key component of Node.js HTTP networking.

More in the `http.Agent` class description later on.

#### Methods

#### `http.createServer()` {#http-createserver-}

Return a new instance of the `http.Server` class.

Usage:

    const server = http.createServer((req, res) => {
      // handle every single request with this callback
    })

#### `http.request()` {#http-request-}

Makes an HTTP request to a server, creating an instance of the `http.ClientRequest` class.

#### `http.get()` {#http-get-}

Similar to `http.request()`, but automatically sets the HTTP method to GET, and calls `req.end()` automatically.

#### Classes

The HTTP module provides 5 classes:

- `http.Agent`
- `http.ClientRequest`
- `http.Server`
- `http.ServerResponse`
- `http.IncomingMessage`

#### `http.Agent` {#http-agent}

Node creates a global instance of the `http.Agent` class to manage connections persistence and reuse for HTTP clients, a key component of Node HTTP networking.

This object makes sure that every request made to a server is queued and a single socket is reused.

It also maintains a pool of sockets. This is key for performance reasons.

#### `http.ClientRequest` {#http-clientrequest}

An `http.ClientRequest` object is created when `http.request()` or `http.get()` is called.

When a response is received, the `response` event is called with the response, with an `http.IncomingMessage` instance as argument.

The returned data of a response can be read in 2 ways:

- you can call the `response.read()` method
- in the `response` event handler you can setup an event listener for the `data` event, so you can listen for the data streamed into.

#### `http.Server` {#http-server}

This class is commonly instantiated and returned when creating a new server using `http.createServer()`.

Once you have a server object, you have access to its methods:

- `close()` stops the server from accepting new connections
- `listen()` starts the HTTP server and listens for connections

#### `http.ServerResponse` {#http-serverresponse}

Created by an `http.Server` and passed as the second parameter to the `request` event it fires.

Commonly known and used in code as `res`:

```language-js
const server = http.createServer((req, res) => {
  // res is an http.ServerResponse object
})
```

The method you'll always call in the handler is `end()`, which closes the response, the message is complete and the server can send it to the client. It must be called on each response.

These methods are used to interact with HTTP headers:

- `getHeaderNames()` get the list of the names of the HTTP headers already set
- `getHeaders()` get a copy of the HTTP headers already set
- `setHeader('headername', value)` sets an HTTP header value
- `getHeader('headername')` gets an HTTP header already set
- `removeHeader('headername')` removes an HTTP header already set
- `hasHeader('headername')` return true if the response has that header set
- `headersSent()` return true if the headers have already been sent to the client

After processing the headers you can send them to the client by calling `response.writeHead()`, which accepts the statusCode as the first parameter, the optional status message, and the headers object.

To send data to the client in the response body, you use `write()`. It will send buffered data to the HTTP response stream.

If the headers were not sent yet using `response.writeHead()`, it will send the headers first, with the status code and message that's set in the request, which you can edit by setting the `statusCode` and `statusMessage` properties values:

```language-js
response.statusCode = 500
response.statusMessage = 'Internal Server Error'
```

#### `http.IncomingMessage` {#http-incomingmessage}

An `http.IncomingMessage` object is created by:

- `http.Server` when listening to the `request` event
- `http.ClientRequest` when listening to the `response` event

It can be used to access the response:

- status using its `statusCode` and `statusMessage` methods
- headers using its `headers` method or `rawHeaders`
- HTTP method using its `method` method
- HTTP version using the `httpVersion` method
- URL using the `url` method
- underlying socket using the `socket` method

The data is accessed using streams, since `http.IncomingMessage` implements the Readable Stream interface.

### Node.js Streams {#node-js-streams}

Streams are one of the fundamental concepts that power Node.js applications.

They are a way to handle reading/writing files, network communications, or any kind of end-to-end information exchange in an efficient way.

Streams are not a concept unique to Node.js. They were introduced in the Unix operating system decades ago, and programs can interact with each other passing streams through the pipe operator (`|`).

For example, in the traditional way, when you tell the program to read a file, the file is read into memory, from start to finish, and then you process it.

Using streams you read it piece by piece, processing its content without keeping it all in memory.

The Node.js `stream` [module](https://nodejs.org/api/stream.html){rel="noopener"} provides the foundation upon which all streaming APIs are build.

#### Why streams?

Streams basically provide two major advantages using other data handling methods:

- **Memory efficiency**: you don't need to load large amounts of data in memory before you are able to process it
- **Time efficiency**: it takes way less time to start processing data as soon as you have it, rather than waiting till the whole data payload is available to start

#### An example of a stream

A typical example is the one of reading files from a disk.

Using the Node.js `fs` module you can read a file, and serve it over HTTP when a new connection is established to your `http` server:

```language-js
const http = require('http')
const fs = require('fs')

const server = http.createServer(function (req, res) {
  fs.readFile(__dirname + '/data.txt', (err, data) => {
    res.end(data)
  })
})

server.listen(3000)
```

`readFile()` reads the full contents of the file, and invokes the callback function when it's done.

`res.end(data)` in the callback will return the file contents to the HTTP client.

If the file is big, the operation will take quite a bit of time. Here is the same thing written using streams:

```language-js
const http = require('http')
const fs = require('fs')

const server = http.createServer((req, res) => {
  const stream = fs.createReadStream(__dirname + '/data.txt')
  stream.pipe(res)
})

server.listen(3000)
```

Instead of waiting until the file is fully read, we start streaming it to the HTTP client as soon as we have a chunk of data ready to be sent.

#### pipe() {#pipe-}

The above example uses the line `stream.pipe(res)`: the `pipe()` method is called on the file stream.

What does this code do? It takes the source, and pipes it into a destination.

You call it on the source stream, so in this case, the file stream is piped to the HTTP response.

The return value of the `pipe()` method is the destination stream, which is a very convenient thing that lets us chain multiple `pipe()` calls, like this:

```language-js
src.pipe(dest1).pipe(dest2)
```

This construct is the same as doing:

```language-js
src.pipe(dest1)
dest1.pipe(dest2)
```

#### Streams-powered Node.js APIs {#streams-powered-node-js-apis}

Due to their advantages, many Node.js core modules provide native stream handling capabilities, most notably:

- `process.stdin` returns a stream connected to stdin
- `process.stdout` returns a stream connected to stdout
- `process.stderr` returns a stream connected to stderr
- `fs.createReadStream()` creates a readable stream to a file
- `fs.createWriteStream()` creates a writable stream to a file
- `net.connect()` initiates a stream-based connection
- `http.request()` returns an instance of the http.ClientRequest class, which is a writable stream
- `zlib.createGzip()` compress data using gzip (a compression algorithm) into a stream
- `zlib.createGunzip()` decompress a gzip stream.
- `zlib.createDeflate()` compress data using deflate (a compression algorithm) into a stream
- `zlib.createInflate()` decompress a deflate stream

#### Different types of streams

There are four classes of streams:

- `Readable`: a stream you can pipe from, but not pipe into (you can receive data, but not send data to it). When you push data into a readable stream, it is buffered, until a consumer starts to read the data.
- `Writable`: a stream you can pipe into, but not pipe from (you can send data, but not receive from it)
- `Duplex`: a stream you can both pipe into and pipe from, basically a combination of a Readable and Writable stream
- `Transform`: a Transform stream is similar to a Duplex, but the output is a transform of its input

#### How to create a readable stream

We get the `Readable` stream from the `stream` module, and we initialize it:

```language-js
const Stream = require('stream')
const readableStream = new Stream.Readable()
```

Now that the stream is initialized, we can send data to it:

```language-js
readableStream.push('hi!')
readableStream.push('ho!')
```

#### How to create a writable stream

To create a writable stream we extend the base `Writable` object, and we implement its `_write()` method.

First create a stream object:

```language-js
const Stream = require('stream')
const writableStream = new Stream.Writable()
```

then implement `_write`:

```language-js
writableStream._write = (chunk, encoding, next) => {
  console.log(chunk.toString())
  next()
}
```

You can now pipe a readable stream in:

```language-js
process.stdin.pipe(writableStream)
```

#### How to get data from a readable stream

How do we read data from a readable stream? Using a writable stream:

```language-js
const Stream = require('stream')

const readableStream = new Stream.Readable()
const writableStream = new Stream.Writable()

writableStream._write = (chunk, encoding, next) => {
  console.log(chunk.toString())
  next()
}

readableStream.pipe(writableStream)

readableStream.push('hi!')
readableStream.push('ho!')
```

You can also consume a readable stream directly, using the `readable` event:

```language-js
readableStream.on('readable', () => {
  console.log(readableStream.read())
})
```

#### How to send data to a writable stream

Using the stream `write()` method:

```language-js
writableStream.write('hey!\n')
```

#### Signaling a writable stream that you ended writing

Use the `end()` method:

```language-js
const Stream = require('stream')

const readableStream = new Stream.Readable()
const writableStream = new Stream.Writable()

writableStream._write = (chunk, encoding, next) => {
  console.log(chunk.toString())
  next()
}

readableStream.pipe(writableStream)

readableStream.push('hi!')
readableStream.push('ho!')

writableStream.end()
```

### The basics of working with MySQL and Node.js {#the-basics-of-working-with-mysql-and-node-js}

MySQL is one of the most popular relational databases in the world.

The Node.js ecosystem has several different packages that allow you to interface with MySQL, store data, retrieve data, and so on.

We'll use [`mysqljs/mysql`](https://github.com/mysqljs/mysql){rel="noopener"}, a package that has over 12,000 GitHub stars and has been around for years.

#### Installing the Node.js MySql package {#installing-the-node-js-mysql-package}

You install it using:

    npm install mysql

#### Initializing the connection to the database

You first include the package:

```language-js
const mysql = require('mysql')
```

and you create a connection:

```language-js
const options = {
  user: 'the_mysql_user_name',
  password: 'the_mysql_user_password',
  database: 'the_mysql_database_name'
}

const connection = mysql.createConnection(options)
```

You initiate a new connection by calling:

```language-js
connection.connect(err => {
  if (err) {
    console.error('An error occurred while connecting to the DB')
    throw err
  }
})
```

#### The connection options

In the above example, the `options` object contained 3 options:

```language-js
const options = {
  user: 'the_mysql_user_name',
  password: 'the_mysql_user_password',
  database: 'the_mysql_database_name'
}
```

There are many more you can use, including:

- `host`, the database hostname, defaults to `localhost`
- `port`, the MySQL server port number, defaults to 3306
- `socketPath`, used to specify a unix socket instead of host and port
- `debug`, by default disabled, can be used for debugging
- `trace`, by default enabled, prints stack traces when errors occur
- `ssl`, used to setup an SSL connection to the server (out of the scope of this tutorial)

#### Perform a SELECT query

Now you are ready to perform an SQL query on the database. The query once executed will invoke a callback function which contains an eventual error, the results and the fields:

```language-js
connection.query('SELECT * FROM todos', (error, todos, fields) => {
  if (error) {
    console.error('An error occurred while executing the query')
    throw error
  }
  console.log(todos)
})
```

You can pass in values which will be automatically escaped:

```language-js
const id = 223
connection.query('SELECT * FROM todos WHERE id = ?', [id], (error, todos, fields) => {
  if (error) {
    console.error('An error occurred while executing the query')
    throw error
  }
  console.log(todos)
})
```

To pass multiple values, just put more elements in the array you pass as the second parameter:

```language-js
const id = 223
const author = 'Flavio'
connection.query('SELECT * FROM todos WHERE id = ? AND author = ?', [id, author], (error,
  if (error) {
    console.error('An error occurred while executing the query')
    throw error
  }
  console.log(todos)
})
```

#### Perform an INSERT query

You can pass an object:

```language-js
const todo = {
  thing: 'Buy the milk'
  author: 'Flavio'
}

connection.query('INSERT INTO todos SET ?', todo, (error, results, fields) => {
  if (error) {
    console.error('An error occurred while executing the query')
    throw error
  }
})
```

If the table has a primary key with `auto_increment`, the value of that will be returned in the `results.insertId`value:

```language-js
const todo = {
  thing: 'Buy the milk'
  author: 'Flavio'
}

connection.query('INSERT INTO todos SET ?', todo, (error, results, fields) => {
  if (error) {
    console.error('An error occurred while executing the query')
    throw error
  }}

  const id = results.resultId
  console.log(id)
)
```

#### Close the connection

When you need to terminate the connection to the database you can call the `end()` method:

```language-js
connection.end()
```

This makes sure any pending query gets sent, and the connection is gracefully terminated.

### The difference between development and production

You can have different configurations for production and development environments.

Node.js assumes it's always running in a development environment. You can signal Node.js that you are running in production by setting the `NODE_ENV=production` environment variable.

This is usually done by executing the command:

    export NODE_ENV=production

in the shell, but it's better to put it in your shell configuration file (like `.bash_profile` with the Bash shell) because otherwise the setting does not persist in case of a system restart.

You can also apply the environment variable by prepending it to your application initialization command:

    NODE_ENV=production node app.js

This environment variable is a convention that is widely used in external libraries as well.

Setting the environment to `production` generally ensures that:

- logging is kept to a minimum, essential level
- more caching levels take place to optimize performance

For example [Pug](https://pugjs.org/api/express.html){rel="noopener"}, the templating library used by Express, compiles in debug mode if `NODE_ENV` is not set to `production`. Express views are compiled in every request in development mode, while in production they are cached. There are many more examples.

Express provides configuration hooks specific to the environment, which are automatically called based on the `NODE_ENV` variable value:

```language-js
app.configure('development', () => {
  // ...
})

app.configure('production', () => {
  // ...
})

app.configure('production', 'staging', () => {
  // ...
})
```

For example you can use this to set different error handlers for different modes:

```language-js
app.configure('development', () => {
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
})

app.configure('production', () => {
  app.use(express.errorHandler())
})
```

### Closing words

I hope this introduction to Node.js will help you get started using it, or help you grasp some of its concepts. And hopefully now you'll know enough to start building some great things!
